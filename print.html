<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Rust By Practice</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="Learn Rust with Example, Exercise and real Practice, written with â¤ï¸ by https://course.rs team">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="why-exercise.html"><strong aria-hidden="true">1.</strong> Rust By Practice</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">2.</strong> Variables</a></li><li class="chapter-item expanded "><a href="basic-types/intro.html"><strong aria-hidden="true">3.</strong> Basic Types</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="basic-types/numbers.html"><strong aria-hidden="true">3.1.</strong> Numbers</a></li><li class="chapter-item "><a href="basic-types/char-bool-unit.html"><strong aria-hidden="true">3.2.</strong> Char, Bool and Unit</a></li><li class="chapter-item "><a href="basic-types/statements-expressions.html"><strong aria-hidden="true">3.3.</strong> Statements and Expressions</a></li><li class="chapter-item "><a href="basic-types/functions.html"><strong aria-hidden="true">3.4.</strong> Functions</a></li></ol></li><li class="chapter-item expanded "><a href="ownership/intro.html"><strong aria-hidden="true">4.</strong> Ownership and Borrowing</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="ownership/ownership.html"><strong aria-hidden="true">4.1.</strong> Ownership</a></li><li class="chapter-item "><a href="ownership/borrowing.html"><strong aria-hidden="true">4.2.</strong> Reference and Borrowing</a></li></ol></li><li class="chapter-item expanded "><a href="compound-types/intro.html"><strong aria-hidden="true">5.</strong> Compound Types</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="compound-types/string.html"><strong aria-hidden="true">5.1.</strong> string</a></li><li class="chapter-item "><a href="compound-types/array.html"><strong aria-hidden="true">5.2.</strong> Array</a></li><li class="chapter-item "><a href="compound-types/slice.html"><strong aria-hidden="true">5.3.</strong> Slice</a></li><li class="chapter-item "><a href="compound-types/tuple.html"><strong aria-hidden="true">5.4.</strong> Tuple</a></li><li class="chapter-item "><a href="compound-types/struct.html"><strong aria-hidden="true">5.5.</strong> Struct</a></li><li class="chapter-item "><a href="compound-types/enum.html"><strong aria-hidden="true">5.6.</strong> Enum</a></li></ol></li><li class="chapter-item expanded "><a href="flow-control.html"><strong aria-hidden="true">6.</strong> Flow Control</a></li><li class="chapter-item expanded "><a href="pattern-match/intro.html"><strong aria-hidden="true">7.</strong> Pattern Match</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="pattern-match/match-iflet.html"><strong aria-hidden="true">7.1.</strong> match, matches! and if let</a></li><li class="chapter-item "><a href="pattern-match/patterns.html"><strong aria-hidden="true">7.2.</strong> Patterns</a></li></ol></li><li class="chapter-item expanded "><a href="method.html"><strong aria-hidden="true">8.</strong> Method &amp; Associated function</a></li><li class="chapter-item expanded "><a href="generics-traits/intro.html"><strong aria-hidden="true">9.</strong> Generics and Traits</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="generics-traits/generics.html"><strong aria-hidden="true">9.1.</strong> Generics</a></li><li class="chapter-item "><a href="generics-traits/const-generics.html"><strong aria-hidden="true">9.2.</strong> Const Generics</a></li><li class="chapter-item "><a href="generics-traits/traits.html"><strong aria-hidden="true">9.3.</strong> Traits</a></li><li class="chapter-item "><a href="generics-traits/trait-object.html"><strong aria-hidden="true">9.4.</strong> Trait Object</a></li><li class="chapter-item "><a href="generics-traits/advanced-traits.html"><strong aria-hidden="true">9.5.</strong> Advanced Traits</a></li></ol></li><li class="chapter-item expanded "><a href="collections/intro.html"><strong aria-hidden="true">10.</strong> Collection Types</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="collections/string.html"><strong aria-hidden="true">10.1.</strong> String</a></li><li class="chapter-item "><a href="collections/vector.html"><strong aria-hidden="true">10.2.</strong> Vector</a></li><li class="chapter-item "><a href="collections/hashmap.html"><strong aria-hidden="true">10.3.</strong> HashMap</a></li></ol></li><li class="chapter-item expanded "><a href="type-conversion.html"><strong aria-hidden="true">11.</strong> Type Conversion todo</a></li><li class="chapter-item expanded "><a href="result-panic/intro.html"><strong aria-hidden="true">12.</strong> Result and panic todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="result-panic/panic.html"><strong aria-hidden="true">12.1.</strong> panic!</a></li><li class="chapter-item "><a href="result-panic/result.html"><strong aria-hidden="true">12.2.</strong> result and ?</a></li></ol></li><li class="chapter-item expanded "><a href="crate-module/intro.html"><strong aria-hidden="true">13.</strong> Crate and module todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="crate-module/crate.html"><strong aria-hidden="true">13.1.</strong> Crate</a></li><li class="chapter-item "><a href="crate-module/module.html"><strong aria-hidden="true">13.2.</strong> Module</a></li><li class="chapter-item "><a href="crate-module/use-pub.html"><strong aria-hidden="true">13.3.</strong> use and pub</a></li></ol></li><li class="chapter-item expanded "><a href="comments-docs.html"><strong aria-hidden="true">14.</strong> Comments and Docs todo</a></li><li class="chapter-item expanded "><a href="formatted-output.html"><strong aria-hidden="true">15.</strong> Formatted output todo</a></li><li class="chapter-item expanded "><a href="lifetime/intro.html"><strong aria-hidden="true">16.</strong> Lifetime todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="lifetime/basic.html"><strong aria-hidden="true">16.1.</strong> basic</a></li><li class="chapter-item "><a href="lifetime/static.html"><strong aria-hidden="true">16.2.</strong> &amp;'static and T: 'static</a></li><li class="chapter-item "><a href="lifetime/advance.html"><strong aria-hidden="true">16.3.</strong> advance</a></li></ol></li><li class="chapter-item expanded "><a href="functional-programing/intro.html"><strong aria-hidden="true">17.</strong> Functional programing todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="functional-programing/cloure.html"><strong aria-hidden="true">17.1.</strong> Closure</a></li><li class="chapter-item "><a href="functional-programing/iterator.html"><strong aria-hidden="true">17.2.</strong> Iterator</a></li></ol></li><li class="chapter-item expanded "><a href="newtype-sized.html"><strong aria-hidden="true">18.</strong> newtype and Sized todo</a></li><li class="chapter-item expanded "><a href="smart-pointers/intro.html"><strong aria-hidden="true">19.</strong> Smart pointers todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="smart-pointers/box.html"><strong aria-hidden="true">19.1.</strong> Box</a></li><li class="chapter-item "><a href="smart-pointers/deref.html"><strong aria-hidden="true">19.2.</strong> Deref</a></li><li class="chapter-item "><a href="smart-pointers/drop.html"><strong aria-hidden="true">19.3.</strong> Drop</a></li><li class="chapter-item "><a href="smart-pointers/rc-arc.html"><strong aria-hidden="true">19.4.</strong> Rc and Arc</a></li><li class="chapter-item "><a href="smart-pointers/cell-refcell.html"><strong aria-hidden="true">19.5.</strong> Cell and RefCell</a></li></ol></li><li class="chapter-item expanded "><a href="weak.html"><strong aria-hidden="true">20.</strong> Weak and Circle reference todo</a></li><li class="chapter-item expanded "><a href="self-referential.html"><strong aria-hidden="true">21.</strong> Self referential todo</a></li><li class="chapter-item expanded "><a href="threads/intro.html"><strong aria-hidden="true">22.</strong> Threads todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="threads/basic-using.html"><strong aria-hidden="true">22.1.</strong> Basic using</a></li><li class="chapter-item "><a href="threads/message-passing.html"><strong aria-hidden="true">22.2.</strong> Message passing</a></li><li class="chapter-item "><a href="threads/sync.html"><strong aria-hidden="true">22.3.</strong> Sync</a></li><li class="chapter-item "><a href="threads/atomic.html"><strong aria-hidden="true">22.4.</strong> Atomic</a></li><li class="chapter-item "><a href="threads/send-sync.html"><strong aria-hidden="true">22.5.</strong> Send and Sync</a></li></ol></li><li class="chapter-item expanded "><a href="global-variables.html"><strong aria-hidden="true">23.</strong> Global variables todo</a></li><li class="chapter-item expanded "><a href="errors.html"><strong aria-hidden="true">24.</strong> Errors todo</a></li><li class="chapter-item expanded "><a href="unsafe/intro.html"><strong aria-hidden="true">25.</strong> Unsafe doing</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="unsafe/inline-asm.html"><strong aria-hidden="true">25.1.</strong> Inline assembly</a></li></ol></li><li class="chapter-item expanded "><a href="macro.html"><strong aria-hidden="true">26.</strong> Macro todo</a></li><li class="chapter-item expanded "><a href="tests/intro.html"><strong aria-hidden="true">27.</strong> Tests todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="tests/write-tests.html"><strong aria-hidden="true">27.1.</strong> Write Tests</a></li><li class="chapter-item "><a href="tests/benchmark.html"><strong aria-hidden="true">27.2.</strong> Benchmark</a></li><li class="chapter-item "><a href="tests/unit-integration.html"><strong aria-hidden="true">27.3.</strong> Unit and Integration</a></li><li class="chapter-item "><a href="tests/assertions.html"><strong aria-hidden="true">27.4.</strong> Assertions</a></li></ol></li><li class="chapter-item expanded "><a href="async/intro.html"><strong aria-hidden="true">28.</strong> Async/Await todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="async/async-await.html"><strong aria-hidden="true">28.1.</strong> async and await!</a></li><li class="chapter-item "><a href="async/future.html"><strong aria-hidden="true">28.2.</strong> Future</a></li><li class="chapter-item "><a href="async/pin-unpin.html"><strong aria-hidden="true">28.3.</strong> Pin and Unpin</a></li><li class="chapter-item "><a href="async/stream.html"><strong aria-hidden="true">28.4.</strong> Stream</a></li></ol></li><li class="chapter-item expanded "><a href="std/intro.html"><strong aria-hidden="true">29.</strong> Standard Library todo</a><a class="toggle"><div>â±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="std/String.html"><strong aria-hidden="true">29.1.</strong> String</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Rust By Practice</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/sunface/rust-by-practice" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="rust-by-practice"><a class="header" href="#rust-by-practice">Rust By Practice</a></h1>
<p>This book was designed for easily diving into Rust, and it's very easy to use: All you need to do is to make each exercise compile without ERRORS and Panics !</p>
<h2 id="read-online"><a class="header" href="#read-online">Read online</a></h2>
<ul>
<li><a href="https://practice.rs">English</a></li>
<li><a href="https://zh.practice.rs">ç®€ä½“ä¸­æ–‡</a></li>
</ul>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>Part of our examples and exercises are borrowed from <a href="https://github.com/rust-lang/rust-by-example">Rust By Example</a>, thanks for your great works!</p>
<p>Although they are so awesome, we have our own secret weapons :)</p>
<ul>
<li>
<p>There are three parts in each chapter: examples, exercises and practices</p>
</li>
<li>
<p>Besides examples, we have <code>a lot of exercises</code>, you can Read, Edit and Run them ONLINE</p>
</li>
<li>
<p>Covering nearly all aspects of Rust, such as async/await, threads, sync primitives, optimizing and standard libraries** etc.</p>
</li>
<li>
<p>Every exercise has its own solutions</p>
</li>
<li>
<p>The overall difficulties are a bit higher and from easy to super hard: easy ğŸŒŸ medium ğŸŒŸğŸŒŸ hard ğŸŒŸğŸŒŸğŸŒŸ super hard ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ</p>
</li>
</ul>
<p><strong>What we want to do is fill in the gap between learning and getting started with real projects.</strong></p>
<h2 id="some-of-our-exercises"><a class="header" href="#some-of-our-exercises">Some of our exercises</a></h2>
<p>ğŸŒŸğŸŒŸğŸŒŸ Tuple struct looks similar to tuples, it has added meaning the struct name provides but has no named fields. It's useful when you want give the whole tuple a name, but don't care the fields's names.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
// fix the error and fill the blanks
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
fn main() {
    let v = Point(___, ___, ___);
    check_color(v);
}

fn check_color(p: Color) {
    let (x, _, _) = p;
    assert_eq!(x, 0);
    assert_eq!(p.1, 127);
    assert_eq!(___, 255);
 }
</code></pre></pre>
<p>ğŸŒŸğŸŒŸ Within the destructuring of a single variable, both by-move and by-reference pattern bindings can be used at the same time. Doing this will result in a partial move of the variable, which means that parts of the variable will be moved while other parts stay. In such a case, the parent variable cannot be used afterwards as a whole, however the parts that are only referenced (and not moved) can still be used.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
// fix errors to make it work
#[derive(Debug)]
struct File {
    name: String,
    data: String,
}
fn main() {
    let f = File {
        name: String::from(&quot;readme.md&quot;),
        data: &quot;Rust By Practice&quot;.to_string()
    };

    let _name = f.name;

    // ONLY modify this line
    println!(&quot;{}, {}, {:?}&quot;,f.name, f.data, f);
}
</code></pre></pre>
<p>ğŸŒŸğŸŒŸ A match guard is an additional if condition specified after the pattern in a match arm that must also match, along with the pattern matching, for that arm to be chosen.</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank to make the code work, `split` MUST be used
fn main() {
    let num = Some(4);
    let split = 5;
    match num {
        Some(x) __ =&gt; assert!(x &lt; split),
        Some(x) =&gt; assert!(x &gt;= split),
        None =&gt; (),
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<h3 id="binding-and-mutablity"><a class="header" href="#binding-and-mutablity">Binding and mutablity</a></h3>
<ol>
<li>ğŸŒŸ A variable can be used only if it has been initialized.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error below with least modifying
fn main() {
    let x: i32; // uninitialized but using, ERROR !
    let y: i32; // uninitialized but also unusing, only warning

    assert_eq!(x, 5);
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ Use <code>mut</code> to mark a variable as mutable.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks in code to make it compile
fn main() {
    let __ =  1;
    __ += 2; 
    
    assert_eq!(x, 3);
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="scope"><a class="header" href="#scope">Scope</a></h3>
<p>A scope is the range within the program for which the item is valid.</p>
<ol start="3">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error below with least modifying
fn main() {
    let x: i32 = 10;
    {
        let y: i32 = 5;
        println!(&quot;The value of x is {} and value of y is {}&quot;, x, y);
    }
    println!(&quot;The value of x is {} and value of y is {}&quot;, x, y); 
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error with using of define_x
fn main() {
    println!(&quot;{}, world&quot;, x); 
}

fn define_x() {
    let x = &quot;hello&quot;;
}
</code></pre></pre>
<h3 id="shadowing"><a class="header" href="#shadowing">Shadowing</a></h3>
<p>You can declare a new variable with the same name as a previous variable, here we can say **the first one is shadowed by the second one.</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// only modify `assert_eq!` to make the `println!` work(print `42` in terminal)
fn main() {
    let x: i32 = 5;
    {
        let x = 12;
        assert_eq!(x, 5);
    }

    assert_eq!(x, 12);

    let x =  42;
    println!(&quot;{}&quot;, x); // Prints &quot;42&quot;.
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// remove a line in code to make it compile
fn main() {
    let mut x: i32 = 1;
    x = 7;
    // shadowing and re-binding
    let x = x; 
    x += 3;


    let y = 4;
    // shadowing
    let y = &quot;I can also be bound to text!&quot;; 

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="unused-varibles"><a class="header" href="#unused-varibles">Unused varibles</a></h3>
<ol>
<li>fix the warning below with :</li>
</ol>
<ul>
<li>ğŸŒŸ  only one solution</li>
<li>ğŸŒŸğŸŒŸ  two distinct solutions</li>
</ul>
<blockquote>
<p>Note: none of the solutions is to remove the line <code>let x = 1</code> </p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = 1; 
}

// warning: unused variable: `x`
</code></pre></pre>
<h3 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h3>
<ol start="8">
<li>ğŸŒŸğŸŒŸ We can use a pattern with <code>let</code> to destructure a tuple to separate variables.</li>
</ol>
<blockquote>
<p>Tips: you can use Shadowing or Mutability</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error below with least modifying
fn main() {
    let (x, y) = (1, 2);
    x += 2;

    assert_eq!(x, 3);
    assert_eq!(y, 2);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="destructuring-assignments"><a class="header" href="#destructuring-assignments">Destructuring assignments</a></h3>
<p>Introducing in Rust 1.59: You can now use tuple, slice, and struct patterns as the left-hand side of an assignment.</p>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<blockquote>
<p>Note: the feature <code>Destructuring assignments</code> need 1.59 or higher Rust version</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let (x, y);
    (x,..) = (3, 4);
    [.., y] = [1, 2];
    // fill the blank to make the code work
    assert_eq!([x,y], __);

    println!(&quot;Success!&quot;)
} 
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-types"><a class="header" href="#basic-types">Basic Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch03-02-data-types.html">Rust Book 3.2 and 3.3</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/base-type/index.html">Rustè¯­è¨€åœ£ç» - åŸºæœ¬ç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="numbers"><a class="header" href="#numbers">Numbers</a></h1>
<h3 id="integer"><a class="header" href="#integer">Integer</a></h3>
<ol>
<li>ğŸŒŸ </li>
</ol>
<blockquote>
<p>Tips: If we don't explicitly give one type to a varible, then the compiler will infer one for us</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// remove something to make it work
fn main() {
    let x: i32 = 5;
    let mut y: u32 = 5;

    y = x;
    
    let z = 10; // type of z ? 

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
//  fill the blank
fn main() {
    let v: u16 = 38_u8 as __;

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<blockquote>
<p>Tips: If we don't explicitly give one type to a varible, then the compiler will infer one for us</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// modify `assert_eq!` to make it work
fn main() {
    let x = 5;
    assert_eq!(&quot;u32&quot;.to_string(), type_of(&amp;x));

    println!(&quot;Success!&quot;)
}

// get the type of given variable, return a string representation of the type  , e.g &quot;i8&quot;, &quot;u8&quot;, &quot;i32&quot;, &quot;u32&quot;
fn type_of&lt;T&gt;(_: &amp;T) -&gt; String {
    format!(&quot;{}&quot;, std::any::type_name::&lt;T&gt;())
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks to make it work
fn main() {
    assert_eq!(i8::MAX, __); 
    assert_eq!(u8::MAX, __); 

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix errors and panics to make it work
fn main() {
   let v1 = 251_u8 + 8;
   let v2 = i8::checked_add(251, 8).unwrap();
   println!(&quot;{},{}&quot;,v1,v2);
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// modify `assert!` to make it work
fn main() {
    let v = 1_024 + 0xff + 0o77 + 0b1111_1111;
    assert!(v == 1579);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="floating-point"><a class="header" href="#floating-point">Floating-Point</a></h3>
<ol start="7">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
//  replace ? with your answer
fn main() {
    let x = 1_000.000_1; // ?
    let y: f32 = 0.12; // f32
    let z = 0.01_f64; // f64

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol>
<li>ğŸŒŸğŸŒŸ make it work in two distinct ways</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    assert!(0.1+0.2==0.3);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="range"><a class="header" href="#range">Range</a></h3>
<ol start="9">
<li>ğŸŒŸğŸŒŸ two goals: 1. modify <code>assert!</code> to make it work 2. make <code>println!</code> output: 97 - 122</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let mut sum = 0;
    for i in -3..2 {
        sum += i
    }

    assert!(sum == -3);

    for c in 'a'..='z' {
        println!(&quot;{}&quot;,c);
    }
}
</code></pre></pre>
<ol start="10">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks
use std::ops::{Range, RangeInclusive};
fn main() {
    assert_eq!((1..__), Range{ start: 1, end: 5 });
    assert_eq!((1..__), RangeInclusive::new(1, 5));

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="computations"><a class="header" href="#computations">Computations</a></h3>
<ol start="11">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks and fix the errors
fn main() {
    // Integer addition
    assert!(1u32 + 2 == __);

    // Integer subtraction
    assert!(1i32 - 2 == __);
    assert!(1u8 - 2 == -1); 
    
    assert!(3 * 50 == __);

    assert!(9.6 / 3.2 == 3.0); // error ! make it work

    assert!(24 % 5 == __);
    // Short-circuiting boolean logic
    assert!(true &amp;&amp; false == __);
    assert!(true || false == __);
    assert!(!true == __);

    // Bitwise operations
    println!(&quot;0011 AND 0101 is {:04b}&quot;, 0b0011u32 &amp; 0b0101);
    println!(&quot;0011 OR 0101 is {:04b}&quot;, 0b0011u32 | 0b0101);
    println!(&quot;0011 XOR 0101 is {:04b}&quot;, 0b0011u32 ^ 0b0101);
    println!(&quot;1 &lt;&lt; 5 is {}&quot;, 1u32 &lt;&lt; 5);
    println!(&quot;0x80 &gt;&gt; 2 is 0x{:x}&quot;, 0x80u32 &gt;&gt; 2);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="char-bool-and-unit"><a class="header" href="#char-bool-and-unit">Char, Bool and Unit</a></h1>
<h3 id="char"><a class="header" href="#char">Char</a></h3>
<ol>
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
// make it work
use std::mem::size_of_val;
fn main() {
    let c1 = 'a';
    assert_eq!(size_of_val(&amp;c1),1); 

    let c2 = 'ä¸­';
    assert_eq!(size_of_val(&amp;c2),3); 

    println!(&quot;Success!&quot;)
} 
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
// make it work
fn main() {
    let c1 = &quot;ä¸­&quot;;
    print_char(c1);
} 

fn print_char(c : char) {
    println!(&quot;{}&quot;, c);
}
</code></pre></pre>
<h3 id="bool"><a class="header" href="#bool">Bool</a></h3>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
// make println! work
fn main() {
    let _f: bool = false;

    let t = true;
    if !t {
        println!(&quot;Success!&quot;)
    }
} 
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">
// make it work
fn main() {
    let f = true;
    let t = true &amp;&amp; false;
    assert_eq!(t, f);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="unit-type"><a class="header" href="#unit-type">Unit type</a></h3>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// make it work, don't modify `implicitly_ret_unit` !
fn main() {
    let _v: () = ();

    let v = (2, 3);
    assert_eq!(v, implicitly_ret_unit());

    println!(&quot;Success!&quot;)
}

fn implicitly_ret_unit() {
    println!(&quot;I will return a ()&quot;)
}

// don't use this one
fn explicitly_ret_unit() -&gt; () {
    println!(&quot;I will return a ()&quot;)
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ what's the size of the unit type?</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// modify `4` in assert to make it work
use std::mem::size_of_val;
fn main() {
    let unit: () = ();
    assert!(size_of_val(&amp;unit) == 4);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="statements-and-expressions"><a class="header" href="#statements-and-expressions">Statements and Expressions</a></h1>
<h3 id="examples"><a class="header" href="#examples">Examples</a></h3>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let x = 5u32;

    let y = {
        let x_squared = x * x;
        let x_cube = x_squared * x;

        // This expression will be assigned to `y`
        x_cube + x_squared + x
    };

    let z = {
        // The semicolon suppresses this expression and `()` is assigned to `z`
        2 * x;
    };

    println!(&quot;x is {:?}&quot;, x);
    println!(&quot;y is {:?}&quot;, y);
    println!(&quot;z is {:?}&quot;, z);
}
</code></pre></pre>
<h3 id="exercises"><a class="header" href="#exercises">Exercises</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// make it work with two ways
fn main() {
   let v = {
       let mut x = 1;
       x += 2
   };

   assert_eq!(v, 3);

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let v = (let x = 3);

   assert!(v == 3);

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = sum(1 , 2);
    assert_eq!(s, 3);

    println!(&quot;Success!&quot;)
}

fn sum(x: i32, y: i32) -&gt; i32 {
    x + y;
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // don't modify the following two lines!
    let (x, y) = (1, 2);
    let s = sum(x, y);

    assert_eq!(s, 3);

    println!(&quot;Success!&quot;)
}

fn sum(x, y: i32) {
    x + y;
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
   print();
}

// replace i32 with another type
fn print() -&gt; i32 {
   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// solve it in two ways
// DON'T let `println!` works
fn main() {
    never_return();

    println!(&quot;Failed!&quot;)
}

fn never_return() -&gt; ! {
    // implement this function, don't modify the fn signatures
    
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership-and-borrowing"><a class="header" href="#ownership-and-borrowing">Ownership and Borrowing</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html">Rust Book 4.1-4.4</a></li>
<li>ç®€ä½“ä¸­æ–‡: [Rustè¯­è¨€åœ£ç» - æ‰€æœ‰æƒä¸å€Ÿç”¨(https://course.rs/basic/ownership/index.html)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ownership"><a class="header" href="#ownership">Ownership</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // use as many approaches as you can to make it work
    let x = String::from(&quot;hello, world&quot;);
    let y = x;
    println!(&quot;{},{}&quot;,x,y);
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Don't modify code in main!
fn main() {
    let s1 = String::from(&quot;hello, world&quot;);
    let s2 = take_ownership(s1);

    println!(&quot;{}&quot;, s2);
}

// Only modify the code below!
fn take_ownership(s: String) {
    println!(&quot;{}&quot;, s);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = give_ownership();
    println!(&quot;{}&quot;, s);
}

// Only modify the code below!
fn give_ownership() -&gt; String {
    let s = String::from(&quot;hello, world&quot;);
    // convert String to Vec
    let _s = s.into_bytes();
    s
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// fix the error without removing code line
fn main() {
    let s = String::from(&quot;hello, world&quot;);

    print_str(s);

    println!(&quot;{}&quot;, s);
}

fn print_str(s: String)  {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">// don't use clone ,use copy instead
fn main() {
    let x = (1, 2, (), &quot;hello&quot;.to_string());
    let y = x.clone();
    println!(&quot;{:?}, {:?}&quot;, x, y);
}
</code></pre></pre>
<h4 id="mutability"><a class="header" href="#mutability">Mutability</a></h4>
<p>Mutability can be changed when ownership is transferred.</p>
<ol start="6">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = String::from(&quot;hello, &quot;);
    
    // modify this line only !
    let s1 = s;

    s1.push_str(&quot;world&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = Box::new(5);
    
    let ...      // implement this line, dont change other lines!
    
    *y = 4;
    
    assert_eq!(*x, 5);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="partial-move"><a class="header" href="#partial-move">Partial move</a></h3>
<p>Within the destructuring of a single variable, both by-move and by-reference pattern bindings can be used at the same time. Doing this will result in a partial move of the variable, which means that parts of the variable will be moved while other parts stay. In such a case, the parent variable cannot be used afterwards as a whole, however the parts that are only referenced (and not moved) can still be used.</p>
<h4 id="example"><a class="header" href="#example">Example</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: Box::new(20),
    };

    // `name` is moved out of person, but `age` is referenced
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // Error! borrow of partially moved value: `person` partial move occurs
    //println!(&quot;The person struct is {:?}&quot;, person);

    // `person` cannot be used but `person.age` can be used as it is not moved
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<h4 id="exercises-1"><a class="header" href="#exercises-1">Exercises</a></h4>
<ol start="8">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

   let _s = t.0;

   // modify this line only, don't use `_s`
   println!(&quot;{:?}&quot;, t);
}
</code></pre></pre>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let t = (String::from(&quot;hello&quot;), String::from(&quot;world&quot;));

    // fill the blanks
    let (__, __) = __;

    println!(&quot;{:?}, {:?}, {:?}&quot;, s1, s2, t); // -&gt; &quot;hello&quot;, &quot;world&quot;, (&quot;hello&quot;, &quot;world&quot;)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference-and-borrowing"><a class="header" href="#reference-and-borrowing">Reference and Borrowing</a></h1>
<h3 id="reference"><a class="header" href="#reference">Reference</a></h3>
<ol>
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   let x = 5;
   // fill the blank
   let p = __;

   println!(&quot;the memory address of x is {:p}&quot;, p); // one possible output: 0x16fa3ac84
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let x = 5;
    let y = &amp;x;

    // modify this line only
    assert_eq!(5, y);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix error
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(s);

    println!(&quot;Success!&quot;)
}

fn borrow_object(s: &amp;String) {}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix error
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    push_str(s);

    println!(&quot;Success!&quot;)
}

fn push_str(s: &amp;mut String) {
    s.push_str(&quot;world&quot;)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    // fill the blank to make it work
    let p = __;
    
    p.push_str(&quot;world&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h4 id="ref"><a class="header" href="#ref">ref</a></h4>
<p><code>ref</code> can be used to take references to a value, similar to <code>&amp;</code>.</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let c = 'ä¸­';

    let r1 = &amp;c;
    // fill the blankï¼Œdont change other code
    let __ r2 = c;

    assert_eq!(*r1, *r2);
    
    // check the equality of the two address strings
    assert_eq!(get_addr(r1),get_addr(r2));

    println!(&quot;Success!&quot;)
}

// get memory address string
fn get_addr(r: &amp;char) -&gt; String {
    format!(&quot;{:p}&quot;, r)
}
</code></pre></pre>
<h3 id="borrowing-rules"><a class="header" href="#borrowing-rules">Borrowing rules</a></h3>
<ol start="7">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// remove something to make it work
// don't remove a whole line !
fn main() {
    let mut s = String::from(&quot;hello&quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    println!(&quot;{}, {}&quot;, r1, r2);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h4 id="mutablity"><a class="header" href="#mutablity">Mutablity</a></h4>
<ol start="8">
<li>ğŸŒŸ Error: Borrow a immutable object as mutable</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    //fix error by modifying this line
    let  s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;mut s);

    println!(&quot;Success!&quot;)
}

fn borrow_object(s: &amp;mut String) {}
</code></pre></pre>
<ol start="9">
<li>ğŸŒŸğŸŒŸ Ok: Borrow a mutable object as immutable</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// this code has no errors!
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    borrow_object(&amp;s);
    
    s.push_str(&quot;world&quot;);

    println!(&quot;Success!&quot;)
}

fn borrow_object(s: &amp;String) {}
</code></pre></pre>
<h3 id="nll"><a class="header" href="#nll">NLL</a></h3>
<ol start="10">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// comment one line to make it work
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    r1.push_str(&quot;world&quot;);
    let r2 = &amp;mut s;
    r2.push_str(&quot;!&quot;);
    
    println!(&quot;{}&quot;,r1);
}
</code></pre></pre>
<ol start="11">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let mut s = String::from(&quot;hello, &quot;);

    let r1 = &amp;mut s;
    let r2 = &amp;mut s;

    // add one line below to make a compiler error: cannot borrow `s` as mutable more than once at a time
    // you can't use r1 and r2 at the same time
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch04-03-slices.html">Rust Book 4.3, 5.1, 6.1, 8.2</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/compound-type/intro.html">Rustè¯­è¨€åœ£ç» - å¤åˆç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string"><a class="header" href="#string">string</a></h1>
<p>The type of string literal <code>&quot;hello, world&quot;</code> is <code>&amp;str</code>, e.g <code>let s: &amp;str = &quot;hello, world&quot;</code>.</p>
<h3 id="str-and-str"><a class="header" href="#str-and-str">str and &amp;str</a></h3>
<ol>
<li>ğŸŒŸ We can't use <code>str</code> type in normal ways, but we can use <code>&amp;str</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix error without adding new line
fn main() {
   let s: str = &quot;hello, world&quot;;

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ We can only use <code>str</code> by boxed it, <code>&amp;</code> can be used to convert <code>Box&lt;str&gt;</code> to <code>&amp;str</code> </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error with at least two solutions
fn main() {
   let s: Box&lt;str&gt; =  &quot;hello, world&quot;.into();
   greetings(s)
}

fn greetings(s: &amp;str) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<h3 id="string-1"><a class="header" href="#string-1">String</a></h3>
<p><code>String</code> type is defined in std and stored as a vector of bytes (Vec<u8>), but guaranteed to always be a valid UTF-8 sequence. String is heap allocated, growable and not null terminated.</p>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank
fn main() {
   let mut s = __;
   s.push_str(&quot;hello, world&quot;);
   s.push('!');

   assert_eq!(s, &quot;hello, world!&quot;);

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix all errors without adding newline
fn main() {
   let  s =  String::from(&quot;hello&quot;);
    s.push(',');
    s.push(&quot; world&quot;);
    s += &quot;!&quot;.to_string();

    println!(&quot;{}&quot;, s)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ <code>replace</code> can be used to replace substring</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank
fn main() {
   let s = String::from(&quot;I like dogs&quot;);
   // Allocate new memory and store the modified string there
   let s1 = s.__(&quot;dogs&quot;, &quot;cats&quot;);

   assert_eq!(s1, &quot;I like cats&quot;);

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<p>More <code>String</code> methods can be found under <a href="https://doc.rust-lang.org/std/string/struct.String.html">String</a> module.</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸ You can only concat a <code>String</code> with <code>&amp;str</code>, and <code>String</code>'s ownership can be moved to another variable</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix errors without removing any line
fn main() {
    let s1 = String::from(&quot;hello,&quot;);
    let s2 = String::from(&quot;world!&quot;);
    let s3 = s1 + s2; 
    assert_eq!(s3,&quot;hello,world!&quot;);
    println!(&quot;{}&quot;,s1);
}
</code></pre></pre>
<h3 id="str-and-string"><a class="header" href="#str-and-string">&amp;str and String</a></h3>
<p>Opsite to the seldom using of <code>str</code>, <code>&amp;str</code> and <code>String</code> are used everywhere!</p>
<ol start="7">
<li>ğŸŒŸğŸŒŸ <code>&amp;str</code> can be converted to <code>String</code> in two ways</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix error with at lest two solutions
fn main() {
   let s =  &quot;hello, world&quot;;
   greetings(s)
}

fn greetings(s: String) {
    println!(&quot;{}&quot;,s)
}
</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ We can use <code>String::from</code> or <code>to_string</code> to convert a <code>&amp;str</code> to <code>String</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// use two approaches to fix the error and without adding a new line
fn main() {
   let s =  &quot;hello, world&quot;.to_string();
   let s1: &amp;str = s;

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="string-escapes"><a class="header" href="#string-escapes">string escapes</a></h3>
<ol start="9">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    // You can use escapes to write bytes by their hexadecimal values
    // fill the blank below to show &quot;I'm writing Rust&quot;
    let byte_escape = &quot;I'm writing Ru\x73__!&quot;;
    println!(&quot;What are you doing\x3F (\\x3F means ?) {}&quot;, byte_escape);

    // ...or Unicode code points.
    let unicode_codepoint = &quot;\u{211D}&quot;;
    let character_name = &quot;\&quot;DOUBLE-STRUCK CAPITAL R\&quot;&quot;;

    println!(&quot;Unicode character {} (U+211D) is called {}&quot;,
                unicode_codepoint, character_name );

   let long_string = &quot;String literals
                        can span multiple lines.
                        The linebreak and indentation here \
                         can be escaped too!&quot;;
    println!(&quot;{}&quot;, long_string);
}
</code></pre></pre>
<ol start="10">
<li>ğŸŒŸğŸŒŸğŸŒŸ Sometimes there are just too many characters that need to be escaped or it's just much more convenient to write a string out as-is. This is where raw string literals come into play.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let raw_str = r&quot;Escapes don't work here: \x3F \u{211D}&quot;;
    // modify below line to make it work
    assert_eq!(raw_str, &quot;Escapes don't work here: ? â„&quot;);

    // If you need quotes in a raw string, add a pair of #s
    let quotes = r#&quot;And then I said: &quot;There is no escape!&quot;&quot;#;
    println!(&quot;{}&quot;, quotes);

    // If you need &quot;# in your string, just use more #s in the delimiter.
    // You can use up to 65535 #s.
    let  delimiter = r###&quot;A string with &quot;# in it. And even &quot;##!&quot;###;
    println!(&quot;{}&quot;, delimiter);

    // fill the blank
    let long_delimiter = __;
    assert_eq!(long_delimiter, &quot;Hello, \&quot;##\&quot;&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="byte-string"><a class="header" href="#byte-string">byte string</a></h3>
<p>Want a string that's not UTF-8? (Remember, str and String must be valid UTF-8). Or maybe you want an array of bytes that's mostly text? Byte strings to the rescue!</p>
<p><strong>Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::str;

fn main() {
    // Note that this is not actually a `&amp;str`
    let bytestring: &amp;[u8; 21] = b&quot;this is a byte string&quot;;

    // Byte arrays don't have the `Display` trait, so printing them is a bit limited
    println!(&quot;A byte string: {:?}&quot;, bytestring);

    // Byte strings can have byte escapes...
    let escaped = b&quot;\x52\x75\x73\x74 as bytes&quot;;
    // ...but no unicode escapes
    // let escaped = b&quot;\u{211D} is not allowed&quot;;
    println!(&quot;Some escaped bytes: {:?}&quot;, escaped);


    // Raw byte strings work just like raw strings
    let raw_bytestring = br&quot;\u{211D} is not escaped here&quot;;
    println!(&quot;{:?}&quot;, raw_bytestring);

    // Converting a byte array to `str` can fail
    if let Ok(my_str) = str::from_utf8(raw_bytestring) {
        println!(&quot;And the same as text: '{}'&quot;, my_str);
    }

    let _quotes = br#&quot;You can also use &quot;fancier&quot; formatting, \
                    like with normal raw strings&quot;#;

    // Byte strings don't have to be UTF-8
    let shift_jis = b&quot;\x82\xe6\x82\xa8\x82\xb1\x82\xbb&quot;; // &quot;ã‚ˆã†ã“ã&quot; in SHIFT-JIS

    // But then they can't always be converted to `str`
    match str::from_utf8(shift_jis) {
        Ok(my_str) =&gt; println!(&quot;Conversion successful: '{}'&quot;, my_str),
        Err(e) =&gt; println!(&quot;Conversion failed: {:?}&quot;, e),
    };
}
</code></pre></pre>
<p>A more detailed listing of the ways to write string literals and escape characters is given in the <a href="https://doc.rust-lang.org/reference/tokens.html">'Tokens' chapter</a> of the Rust Reference.</p>
<h3 id="string-index"><a class="header" href="#string-index">string index</a></h3>
<ol start="11">
<li>ğŸŒŸğŸŒŸğŸŒŸ You can't use index to access a char in a string, but you can use slice <code>&amp;s1[start..end]</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s1 = String::from(&quot;hi,ä¸­å›½&quot;);
    let h = s1[0]; //modify this line to fix the error, tips: `h` only takes 1 byte in UTF8 format
    assert_eq!(h, &quot;h&quot;);

    let h1 = &amp;s1[3..5];//modify this line to fix the error, tips: `ä¸­`  takes 3 bytes in UTF8 format
    assert_eq!(h1, &quot;ä¸­&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="operate-on-utf8-string"><a class="header" href="#operate-on-utf8-string">operate on UTF8 string</a></h3>
<ol start="12">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // fill the blank to print each char in &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;
    for c in &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;.__ {
        println!(&quot;{}&quot;, c)
    }
}
</code></pre></pre>
<h4 id="utf8_slice"><a class="header" href="#utf8_slice">utf8_slice</a></h4>
<p>You can use <a href="https://docs.rs/utf8_slice/1.0.0/utf8_slice/fn.slice.html">utf8_slice</a> to slice UTF8 string, it can index chars instead of bytes.</p>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use utf_slice;
fn main() {
   let s = &quot;The ğŸš€ goes to the ğŸŒ‘!&quot;;

   let rocket = utf8_slice::slice(s, 4, 5);
   // Will equal &quot;ğŸš€&quot;
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="array"><a class="header" href="#array">Array</a></h1>
<p>The type of array is <code>[T; Lengh]</code>, as you can see, array's lengh is part of their type signature. So their length must be known at compile time.</p>
<p>For example, you cant initialized an array as below:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init_arr(n: i32) {
    let arr = [1; n];
}
<span class="boring">}
</span></code></pre></pre>
<p>This will cause an error, because the compile have no idea of the exact size of the array in compile time.</p>
<ol>
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // fill the blank with proper array type
    let arr: __ = [1, 2, 3, 4, 5];

    // modify below to make it work
    assert!(arr.len() == 4);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // we can ignore parts of the array type or even the whole type, let the compiler infer it for us
    let arr0 = [1, 2, 3];
    let arr: [_; 3] = ['a', 'b', 'c'];
    
    // fill the blank
    // Arrays are stack allocated, `std::mem::size_of_val` return the bytes which array occupies
    // A char takes 4 byte in Rust: Unicode char
    assert!(std::mem::size_of_val(&amp;arr) == __);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ All elements in an array can be initialized to the same value at once.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // fill the blank
    let list: [i32; 100] = __ ;

    assert!(list[0] == 1);
    assert!(list.len() == 100);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ All elements in an array must be of the same type</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    // fix the error
    let _arr = [1, 2, '3'];

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ Indexing starts at 0.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr = ['a', 'b', 'c'];
    
    let ele = arr[1]; // only modify this line to make the code work!

    assert!(ele == 'a');

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸ Out of bounds indexing causes <code>panic</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error
fn main() {
    let names = [String::from(&quot;Sunfei&quot;), &quot;Sunface&quot;.to_string()];
    
    // `get` returns an Option&lt;T&gt;, it's safe to use
    let name0 = names.get(0).unwrap();

    // but indexing is not safe
    let _name1 = &amp;names[2];

    println!(&quot;Success!&quot;)
}

</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="slice"><a class="header" href="#slice">Slice</a></h1>
<p>Slices are similar to arrays, but their length is not known at compile time, so you can't use slice directly.</p>
<ol>
<li>ğŸŒŸğŸŒŸ Here, both <code>[i32]</code> and <code>str</code> are slice types, but directly using it will cause errors. You have to use the reference of the slice instead: <code>&amp;[i32]</code>, <code>&amp;str</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors, DON'T add new lines!
fn main() {
    let arr = [1, 2, 3];
    let s1: [i32] = arr[0..2];

    let s2: str = &quot;hello, world&quot; as str;

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<p>A slice reference is a two-word object, for simplicity reasons, from now on we will use slice instead of <code>slice reference</code>.  The first word is a pointer to the data, and the second word is the length of the slice. The word size is the same as usize, determined by the processor architecture eg 64 bits on an x86-64. Slices can be used to borrow a section of an array, and have the type signature <code>&amp;[T]</code>.</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr: [char; 3] = ['ä¸­', 'å›½', 'äºº'];

    let slice = &amp;arr[..2];
    
    // modify '6' to make it work
    // TIPS: slice( reference ) IS NOT an array, if it is an array, then `assert!` will passed: each of the two UTF-8 chars 'ä¸­' and 'å›½'  occupies 3 bytes, 2 * 3 = 6
    assert!(std::mem::size_of_val(&amp;slice) == 6);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
  let arr: [i32; 5] = [1, 2, 3, 4, 5];
  // fill the blanks to make the code work
  let slice: __ = __;
  assert_eq!(slice, &amp;[2, 3, 4]);

  println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="string-slices"><a class="header" href="#string-slices">string slices</a></h3>
<ol start="4">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = String::from(&quot;hello&quot;);

    let slice1 = &amp;s[0..2];
    // fill the blank to make the code work, DON'T USE 0..2 again
    let slice2 = &amp;s[__];

    assert_eq!(slice1, slice2);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let s = &quot;ä½ å¥½ï¼Œä¸–ç•Œ&quot;;
    // modify this line to make the code work
    let slice = &amp;s[0..2];

    assert!(slice == &quot;ä½ &quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ <code>&amp;String</code> can be implicitly converted into <code>&amp;str</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix errors
fn main() {
    let mut s = String::from(&quot;hello world&quot;);

    // here, &amp;s is `&amp;String` type, but `first_word` need a `&amp;str` type.
    // it works because `&amp;String` can be implicitly converted to `&amp;str, If you want know more ,this is called `Deref` 
    let word = first_word(&amp;s);

    s.clear(); // error!

    println!(&quot;the first word is: {}&quot;, word);
}
fn first_word(s: &amp;str) -&gt; &amp;str {
    &amp;s[..1]
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuple"><a class="header" href="#tuple">Tuple</a></h1>
<ol>
<li>ğŸŒŸ Elements in a tuple can have different types. Tuple's type signature is <code>(T1, T2, ...)</code>, where <code>T1</code>, <code>T2</code> are the types of tuple's members.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let _t0: (u8,i16) = (0, -1);
    // Tuples can be tuple's members
    let _t1: (u8, (i16, u32)) = (0, (-1, 1));
    // fill the blanks to make the code work
    let t: (u8, __, i64, __, __) = (1u8, 2u16, 3i64, &quot;hello&quot;, String::from(&quot;, world&quot;));

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ Members can be extracted from the tuple using indexing.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// make it works
fn main() {
   let t = (&quot;i&quot;, &quot;am&quot;, &quot;sunface&quot;);
   assert_eq!(t.1, &quot;sunface&quot;);

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸ Long tuples  cannot be printed</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error
fn main() {
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    println!(&quot;too long tuple: {:?}&quot;, too_long_tuple);
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸ Destructuring tuple with pattern.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let tup = (1, 6.4, &quot;hello&quot;);

    // fill the blank to make the code work
    let __ = tup;

    assert_eq!(x, 1);
    assert_eq!(y, &quot;hello&quot;);
    assert_eq!(z, 6.4);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ Destructure assignments.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let (x, y, z);

    // fill the blank
    __ = (1, 2, 3);
    
    assert_eq!(x, 3);
    assert_eq!(y, 1);
    assert_eq!(z, 2);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸ Tuples can be used as function arguments and return values</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
   // fill the blank, need a few computations here.
   let (x, y) = sum_multiply(__);

   assert_eq!(x, 5);
   assert_eq!(y, 6);

   println!(&quot;Success!&quot;)
}

fn sum_multiply(nums: (i32, i32)) -&gt; (i32, i32) {
    (nums.0 + nums.1, nums.0 * nums.1)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct"><a class="header" href="#struct">Struct</a></h1>
<h3 id="there-types-of-structs"><a class="header" href="#there-types-of-structs">There types of structs</a></h3>
<ol>
<li>ğŸŒŸ We must specify concrete values for each of the fields in struct.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error
struct Person {
    name: String,
    age: u8,
    hobby: String
}
fn main() {
    let age = 30;
    let p = Person {
        name: String::from(&quot;sunface&quot;),
        age,
    };

    println!(&quot;Success!&quot;)
} 
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ Unit struct don't have any fields. It can be useful when you need to implement a trait on some type but donâ€™t have any data that you want to store in the type itself. </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Unit;
trait SomeTrait {
    // ...Some behavours defines here
}

// We don't care the the fields are in Unit, but we care its behaviors.
// So we use a struct with no fields and implement some behaviors for it
impl SomeTrait for Unit {  }
fn main() {
    let u = Unit;
    do_something_with_unit(u);

    println!(&quot;Success!&quot;)
} 

// fill the blank to make the code work
fn do_something_with_unit(u: __) {   }
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ Tuple struct looks similar to tuples, it has added meaning the struct name provides but has no named fields. It's useful when you want give the whole tuple a name, but don't care the fields's names.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the error and fill the blanks
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);
fn main() {
    let v = Point(__, __, __);
    check_color(v);

    println!(&quot;Success!&quot;)
}   

fn check_color(p: Color) {
    let (x, _, _) = p;
    assert_eq!(x, 0);
    assert_eq!(p.1, 127);
    assert_eq!(__, 255);
 }
</code></pre></pre>
<h3 id="operate-on-structs"><a class="header" href="#operate-on-structs">Operate on structs</a></h3>
<ol start="4">
<li>ğŸŒŸ You can make a whole struct mutable when instantiate it, but Rust doesn't allow us to mark only certain fields as mutable.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank and fix the error without adding/removing new line
struct Person {
    name: String,
    age: u8,
}
fn main() {
    let age = 18;
    let p = Person {
        name: String::from(&quot;sunface&quot;),
        age,
    };

    // how can you believe sunface is only 18? 
    p.age = 30;

    // fill the lank
    __ = String::from(&quot;sunfei&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ Using <em>field init shorthand syntax</em> to reduct repetitions.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank
struct Person {
    name: String,
    age: u8,
}
fn main() {
    println!(&quot;Success!&quot;)
} 

fn build_person(name: String, age: u8) -&gt; Person {
    Person {
        age,
        __
    }
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸ You can create instance from other instance with <em>struct update syntax</em></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank to make the code work
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
fn main() {
    let u1 = User {
        email: String::from(&quot;someone@example.com&quot;),
        username: String::from(&quot;sunface&quot;),
        active: true,
        sign_in_count: 1,
    };

    let u2 = set_email(u1);

    println!(&quot;Success!&quot;)
} 

fn set_email(u: User) -&gt; User {
    User {
        email: String::from(&quot;contact@im.dev&quot;),
        __
    }
}
</code></pre></pre>
<h3 id="print-the-structs"><a class="header" href="#print-the-structs">Print the structs</a></h3>
<ol start="7">
<li>ğŸŒŸğŸŒŸ We can use <code>#[derive(Debug)]</code> to <a href="https://doc.rust-lang.org/book/ch05-02-example-structs.html?highlight=%23%5Bderive(Debug)%5D#adding-useful-functionality-with-derived-traits">make a struct prinable</a>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks to make the code work
#[__]
struct Rectangle {
    width: u32,
    height: u32,
}

fn main() {
    let scale = 2;
    let rect1 = Rectangle {
        width: dbg!(30 * scale), // print debug info to stderr and assign the value of  `30 * scale` to `width`
        height: 50,
    };

    dbg!(&amp;rect1); // print debug info to stderr

    println!(__, rect1); // print debug info to stdout
}
</code></pre></pre>
<h3 id="partial-move-1"><a class="header" href="#partial-move-1">Partial move</a></h3>
<p>Within the destructuring of a single variable, both by-move and by-reference pattern bindings can be used at the same time. Doing this will result in a partial move of the variable, which means that parts of the variable will be moved while other parts stay. In such a case, the parent variable cannot be used afterwards as a whole, however the parts that are only referenced (and not moved) can still be used.</p>
<h4 id="example-1"><a class="header" href="#example-1">Example</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    #[derive(Debug)]
    struct Person {
        name: String,
        age: Box&lt;u8&gt;,
    }

    let person = Person {
        name: String::from(&quot;Alice&quot;),
        age: Box::new(20),
    };

    // `name` is moved out of person, but `age` is referenced
    let Person { name, ref age } = person;

    println!(&quot;The person's age is {}&quot;, age);

    println!(&quot;The person's name is {}&quot;, name);

    // Error! borrow of partially moved value: `person` partial move occurs
    //println!(&quot;The person struct is {:?}&quot;, person);

    // `person` cannot be used but `person.age` can be used as it is not moved
    println!(&quot;The person's age from person struct is {}&quot;, person.age);
}
</code></pre></pre>
<h4 id="exercises-2"><a class="header" href="#exercises-2">Exercises</a></h4>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix errors to make it work
#[derive(Debug)]
struct File {
    name: String,
    data: String,
}
fn main() {
    let f = File {
        name: String::from(&quot;readme.md&quot;),
        data: &quot;Rust By Practice&quot;.to_string()
    };

    let _name = f.name;

    // ONLY modify this line
    println!(&quot;{}, {}, {:?}&quot;,f.name, f.data, f);
} 
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="enum"><a class="header" href="#enum">Enum</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸ Enums can be created with explicit discriminator.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors
enum Number {
    Zero,
    One,
    Two,
}

enum Number1 {
    Zero = 0,
    One,
    Two,
}

// C-like enum
enum Number2 {
    Zero = 0.0,
    One = 1.0,
    Two = 2.0,
}


fn main() {
    // a enum variant can be converted to a integer by `as`
    assert_eq!(Number::One, Number1::One);
    assert_eq!(Number1::One, Number2::One);

    println!(&quot;Success!&quot;)
} 
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸ each enum variant can hold its own data.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg1 = Message::Move{__}; // instantiating with x = 1, y = 2 
    let msg2 = Message::Write(__); // instantiating with &quot;hello, world!&quot;

    println!(&quot;Success!&quot;)
} 
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ we can get the data which a enum variant is holding by pattern match</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank and fix the error
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msg = Message::Move{x: 1, y: 2};

    if let Message::Move{__} = msg {
        assert_eq!(a, b);
    } else {
        panic!(&quot;NEVER LET THIS RUNï¼&quot;);
    }

    println!(&quot;Success!&quot;)
} 
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank and fix the errors
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs: __ = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }
} 

fn show_message(msg: Message) {
    println!(&quot;{}&quot;, msg);
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ As there is no <code>null</code> in Rust, we have to use enum  <code>Option&lt;T&gt;</code>  to deal the cases when value is absent.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank to make the `println` work.
// also add some code to prevent the `panic` from running.
fn main() {
    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    if let __ = six {
        println!(&quot;{}&quot;, n);

        println!(&quot;Success!&quot;)
    } 
        
    panic!(&quot;NEVER LET THIS RUNï¼&quot;);
} 

fn plus_one(x: Option&lt;i32&gt;) -&gt; Option&lt;i32&gt; {
    match x {
        __ =&gt; None,
        __ =&gt; Some(i + 1),
    }
}
</code></pre></pre>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ implement a <code>linked-list</code> via enums.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use crate::List::*;

enum List {
    // Cons: Tuple struct that wraps an element and a pointer to the next node
    Cons(u32, Box&lt;List&gt;),
    // Nil: A node that signifies the end of the linked list
    Nil,
}

// Methods can be attached to an enum
impl List {
    // Create an empty list
    fn new() -&gt; List {
        // `Nil` has type `List`
        Nil
    }

    // Consume a list, and return the same list with a new element at its front
    fn prepend(self, elem: u32) -&gt; __ {
        // `Cons` also has type List
        Cons(elem, Box::new(self))
    }

    // Return the length of the list
    fn len(&amp;self) -&gt; u32 {
        // `self` has to be matched, because the behavior of this method
        // depends on the variant of `self`
        // `self` has type `&amp;List`, and `*self` has type `List`, matching on a
        // concrete type `T` is preferred over a match on a reference `&amp;T`
        // after Rust 2018 you can use self here and tail (with no ref) below as well,
        // rust will infer &amp;s and ref tail. 
        // See https://doc.rust-lang.org/edition-guide/rust-2018/ownership-and-lifetimes/default-match-bindings.html
        match *self {
            // Can't take ownership of the tail, because `self` is borrowed;
            // instead take a reference to the tail
            Cons(_, ref tail) =&gt; 1 + tail.len(),
            // Base Case: An empty list has zero length
            Nil =&gt; 0
        }
    }

    // Return representation of the list as a (heap allocated) string
    fn stringify(&amp;self) -&gt; String {
        match *self {
            Cons(head, __ tail) =&gt; {
                // `format!` is similar to `print!`, but returns a heap
                // allocated string instead of printing to the console
                format!(&quot;{}, {}&quot;, head, tail.__())
            },
            Nil =&gt; {
                format!(&quot;Nil&quot;)
            },
        }
    }
}

fn main() {
    // Create an empty linked list
    let mut list = List::new();

    // Prepend some elements
    list = list.prepend(1);
    list = list.prepend(2);
    list = list.prepend(3);

    // Show the final state of the list
    println!(&quot;linked list has length: {}&quot;, list.len());
    println!(&quot;{}&quot;, list.stringify());
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flow-control"><a class="header" href="#flow-control">Flow control</a></h1>
<h3 id="ifelse"><a class="header" href="#ifelse">if/else</a></h3>
<ol>
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks
fn main() {
    let n = 5;

    if n &lt; 0 {
        println!(&quot;{} is negative&quot;, n);
    } __ n &gt; 0 {
        println!(&quot;{} is positive&quot;, n);
    } __ {
        println!(&quot;{} is zero&quot;, n);
    }
} 
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ <code>if/else</code> expression can be used in assignments.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors
fn main() {
    let n = 5;

    let big_n =
        if n &lt; 10 &amp;&amp; n &gt; -10 {
            println!(&quot;, and is a small number, increase ten-fold&quot;);

            10 * n
        } else {
            println!(&quot;, and is a big number, halve the number&quot;);

            n / 2.0 ;
        }

    println!(&quot;{} -&gt; {}&quot;, n, big_n);
} 
</code></pre></pre>
<h3 id="for"><a class="header" href="#for">for</a></h3>
<ol start="3">
<li>ğŸŒŸ The <code>for in</code> construct can be used to iterate through an Iterator, e.g a range <code>a..b</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    for n in 1..=100 { // modify this line to make the code work
        if n == 100 {
            panic!(&quot;NEVER LET THIS RUN&quot;)
        }
    }

    println!(&quot;Success!&quot;)
} 
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors without adding or removing lines
fn main() {
    let names = [String::from(&quot;liming&quot;),String::from(&quot;hanmeimei&quot;)];
    for name in names {
        // do something with name...
    }

    println!(&quot;{:?}&quot;, names);

    let numbers = [1, 2, 3];
    // the elements in numbers are Copyï¼Œso there is no move here
    for n in numbers {
        // do something with name...
    }
    
    println!(&quot;{:?}&quot;, numbers);
} 
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn main() {
    let a = [4, 3, 2, 1];

    // iterate the indexing and value in 'a'
    for (i,v) in a.__ {
        println!(&quot;The {}th element is {}&quot;,i+1,v);
    }
}
</code></pre></pre>
<h3 id="while"><a class="header" href="#while">while</a></h3>
<ol start="6">
<li>ğŸŒŸğŸŒŸ The <code>while</code> keyword can be used to run a loop when a condition is true.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks to make the last println! work !
fn main() {
    // A counter variable
    let mut n = 1;

    // Loop while the condition is true
    while n __ 10 {
        if n % 15 == 0 {
            println!(&quot;fizzbuzz&quot;);
        } else if n % 3 == 0 {
            println!(&quot;fizz&quot;);
        } else if n % 5 == 0 {
            println!(&quot;buzz&quot;);
        } else {
            println!(&quot;{}&quot;, n);
        }


        __;
    }

    println!(&quot;n reached {}, soloop is over&quot;,n);
}
</code></pre></pre>
<h3 id="continue-and-break"><a class="header" href="#continue-and-break">continue and break</a></h3>
<ol start="7">
<li>ğŸŒŸ use <code>break</code> to break the loop.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n == 66 {
           __
       }
       n += 1;
    }

    assert_eq!(n, 66);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ <code>continue</code> will skip over the remaining code in current iteration and go to the next iteration.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks
fn main() {
    let mut n = 0;
    for i in 0..=100 {
       if n != 66 {
           n+=1;
           __;
       }
       
       __
    }

    assert_eq!(n, 66);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="loop"><a class="header" href="#loop">loop</a></h3>
<ol start="9">
<li>ğŸŒŸğŸŒŸ loop is usually used together with <code>break</code> or <code>continue</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks
fn main() {
    let mut count = 0u32;

    println!(&quot;Let's count until infinity!&quot;);

    // Infinite loop
    loop {
        count += 1;

        if count == 3 {
            println!(&quot;three&quot;);

            // Skip the rest of this iteration
            __;
        }

        println!(&quot;{}&quot;, count);

        if count == 5 {
            println!(&quot;OK, that's enough&quot;);

            __;
        }
    }

    assert_eq!(count, 5);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="10">
<li>ğŸŒŸğŸŒŸ loop is an expression, so we can use it with <code>break</code> to return a value</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            __;
        }
    };

    assert_eq!(result, 20);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="11">
<li>ğŸŒŸğŸŒŸğŸŒŸ It's possible to break or continue outer loops when dealing with nested loops. In these cases, the loops must be annotated with some 'label, and the label must be passed to the break/continue statement.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
fn main() {
    let mut count = 0;
    'outer: loop {
        'inner1: loop {
            if count &gt;= 20 {
                // This would break only the inner1 loop
                break 'inner1; // `break` is also ok 
            }
            count += 2;
        }

        count += 5;

        'inner2: loop {
            if count &gt;= 30 {
                // This breaks the outer loop
                break 'outer;
            }

            // This will continue the outer loop
            continue 'outer;
        }
    }

    assert!(count == __);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pattern-match"><a class="header" href="#pattern-match">Pattern Match</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch18-00-patterns.html">Rust Book 18</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/match-pattern/intro.html">Rustè¯­è¨€åœ£ç» - æ¨¡å¼åŒ¹é…</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="match-if-let"><a class="header" href="#match-if-let">match, if let</a></h1>
<h3 id="match"><a class="header" href="#match">match</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blanks
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East =&gt; println!(&quot;East&quot;),
        __  =&gt; { // matching South or North here
            println!(&quot;South or North&quot;);
        },
        _ =&gt; println!(__),
    };
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ match is an expression, so we can use it in assignments</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let boolean = true;

    // fill the blank with an match expression:
    //
    // boolean = true =&gt; binary = 1
    // boolean = false =&gt;  binary = 0
    let binary = __;

    assert_eq!(binary, 1);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ using match to get the data an enum variant holds</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}

fn main() {
    let msgs = [
        Message::Quit,
        Message::Move{x:1, y:3},
        Message::ChangeColor(255,255,0)
    ];

    for msg in msgs {
        show_message(msg)
    }

    println!(&quot;Success!&quot;)
} 

fn show_message(msg: Message) {
    match msg {
        __ =&gt; { // match  Message::Move
            assert_eq!(a, 1);
            assert_eq!(b, 3);
        },
        Message::ChangeColor(_, g, b) =&gt; {
            assert_eq!(g, __);
            assert_eq!(b, __);
        }
        __ =&gt; println!(&quot;no data in these variants&quot;)
    }
}
</code></pre></pre>
<h3 id="matches"><a class="header" href="#matches">matches!</a></h3>
<p><a href="https://doc.rust-lang.org/stable/core/macro.matches.html"><code>matches!</code></a> looks like <code>match</code>, but can do something different</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let alphabets = ['a', 'E', 'Z', '0', 'x', '9' , 'Y'];

    // fill the blank with `matches!` to make the code work
    for ab in alphabets {
        assert!(__)
    }

    println!(&quot;Success!&quot;)
} 
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
enum MyEnum {
    Foo,
    Bar
}

fn main() {
    let mut count = 0;

    let v = vec![MyEnum::Foo,MyEnum::Bar,MyEnum::Foo];
    for e in v {
        if e == MyEnum::Foo { // fix the error with changing only this line
            count += 1;
        }
    }

    assert_eq!(count, 2);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="if-let"><a class="header" href="#if-let">if let</a></h3>
<p>For some cases, when matching enums, <code>match</code> is too heavy, we can use <code>if let</code> instead.</p>
<ol start="6">
<li>ğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let o = Some(7);

    // remove the whole `match` block, using `if let` instead 
    match o {
        Some(i) =&gt; {
            println!(&quot;This is a really long string and `{:?}`&quot;, i);

            println!(&quot;Success!&quot;)
        }
        _ =&gt; {}
    };
}
</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank
enum Foo {
    Bar(u8)
}

fn main() {
    let a = Foo::Bar(1);

    __ {
        println!(&quot;foobar holds the value: {}&quot;, i);

        println!(&quot;Success!&quot;)
    }
}
</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
enum Foo {
    Bar,
    Baz,
    Qux(u32)
}

fn main() {
    let a = Foo::Qux(10);

    // remove the codes below, using `match` instead 
    if let Foo::Bar = a {
        println!(&quot;match foo::bar&quot;)
    } else if let Foo::Baz = a {
        println!(&quot;match foo::baz&quot;)
    } else {
        println!(&quot;match others&quot;)
    }
}
</code></pre></pre>
<h3 id="shadowing-1"><a class="header" href="#shadowing-1">Shadowing</a></h3>
<ol start="9">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors in-place
fn main() {
    let age = Some(30);
    if let Some(age) = age { // create a new variable with the same name as previous `age`
       assert_eq!(age, Some(30));
    } // the new variable `age` goes out of scope here
    
    match age {
        // match can also introduce a new shadowed variable
        Some(age) =&gt;  println!(&quot;age is a new variable, it's value is {}&quot;,age),
        _ =&gt; ()
    }
 }
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="patterns"><a class="header" href="#patterns">Patterns</a></h1>
<ol>
<li>ğŸŒŸğŸŒŸ use <code>|</code> to match several values, use <code>..=</code> to match a inclusive range</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {}
fn match_number(n: i32) {
    match n {
        // match a single value
        1 =&gt; println!(&quot;One!&quot;),
        // fill in the blank with `|`, DON'T use `..` ofr `..=`
        __ =&gt; println!(&quot;match 2 -&gt; 5&quot;),
        // match an inclusive range
        6..=10 =&gt; {
            println!(&quot;match 6 -&gt; 10&quot;)
        },
        _ =&gt; {
            println!(&quot;match 11 -&gt; +infinite&quot;)
        }
    }
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸğŸŒŸ The <code>@</code> operator lets us create a variable that holds a value at the same time we are testing that value to see whether it matches a pattern.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Point {
    x: i32,
    y: i32,
}

fn main() {
    // fill in the blank to let p match the second arm
    let p = Point { x: __, y: __ };

    match p {
        Point { x, y: 0 } =&gt; println!(&quot;On the x axis at {}&quot;, x),
        // second arm
        Point { x: 0..=5, y: y@ (10 | 20 | 30) } =&gt; println!(&quot;On the y axis at {}&quot;, y),
        Point { x, y } =&gt; println!(&quot;On neither axis: ({}, {})&quot;, x, y),
    }
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors
enum Message {
    Hello { id: i32 },
}

fn main() {
    let msg = Message::Hello { id: 5 };

    match msg {
        Message::Hello {
            id:  3..=7,
        } =&gt; println!(&quot;Found an id in range [3, 7]: {}&quot;, id),
        Message::Hello { id: newid@10 | 11 | 12 } =&gt; {
            println!(&quot;Found an id in another range [10, 12]: {}&quot;, newid)
        }
        Message::Hello { id } =&gt; println!(&quot;Found some other id: {}&quot;, id),
    }
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ A match guard is an additional if condition specified after the pattern in a match arm that must also match, along with the pattern matching, for that arm to be chosen.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blank to make the code work, `split` MUST be used
fn main() {
    let num = Some(4);
    let split = 5;
    match num {
        Some(x) __ =&gt; assert!(x &lt; split),
        Some(x) =&gt; assert!(x &gt;= split),
        None =&gt; (),
    }

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ Ignoring remaining parts of the value with <code>..</code></li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill the blank to make the code work
fn main() {
    let numbers = (2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048);

    match numbers {
        __ =&gt; {
           assert_eq!(first, 2);
           assert_eq!(last, 2048);
        }
    }

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-function--method"><a class="header" href="#associated-function--method">Associated function &amp; Method</a></h1>
<h2 id="examples-1"><a class="header" href="#examples-1">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point {
    x: f64,
    y: f64,
}

// Implementation block, all `Point` associated functions &amp; methods go in here
impl Point {
    // This is an &quot;associated function&quot; because this function is associated with
    // a particular type, that is, Point.
    //
    // Associated functions don't need to be called with an instance.
    // These functions are generally used like constructors.
    fn origin() -&gt; Point {
        Point { x: 0.0, y: 0.0 }
    }

    // Another associated function, taking two arguments:
    fn new(x: f64, y: f64) -&gt; Point {
        Point { x: x, y: y }
    }
}

struct Rectangle {
    p1: Point,
    p2: Point,
}

impl Rectangle {
    // This is a method
    // `&amp;self` is sugar for `self: &amp;Self`, where `Self` is the type of the
    // caller object. In this case `Self` = `Rectangle`
    fn area(&amp;self) -&gt; f64 {
        // `self` gives access to the struct fields via the dot operator
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        // `abs` is a `f64` method that returns the absolute value of the
        // caller
        ((x1 - x2) * (y1 - y2)).abs()
    }

    fn perimeter(&amp;self) -&gt; f64 {
        let Point { x: x1, y: y1 } = self.p1;
        let Point { x: x2, y: y2 } = self.p2;

        2.0 * ((x1 - x2).abs() + (y1 - y2).abs())
    }

    // This method requires the caller object to be mutable
    // `&amp;mut self` desugars to `self: &amp;mut Self`
    fn translate(&amp;mut self, x: f64, y: f64) {
        self.p1.x += x;
        self.p2.x += x;

        self.p1.y += y;
        self.p2.y += y;
    }
}

// `Pair` owns resources: two heap allocated integers
struct Pair(Box&lt;i32&gt;, Box&lt;i32&gt;);

impl Pair {
    // This method &quot;consumes&quot; the resources of the caller object
    // `self` desugars to `self: Self`
    fn destroy(self) {
        // Destructure `self`
        let Pair(first, second) = self;

        println!(&quot;Destroying Pair({}, {})&quot;, first, second);

        // `first` and `second` go out of scope and get freed
    }
}

fn main() {
    let rectangle = Rectangle {
        // Associated functions are called using double colons
        p1: Point::origin(),
        p2: Point::new(3.0, 4.0),
    };

    // Methods are called using the dot operator
    // Note that the first argument `&amp;self` is implicitly passed, i.e.
    // `rectangle.perimeter()` === `Rectangle::perimeter(&amp;rectangle)`
    println!(&quot;Rectangle perimeter: {}&quot;, rectangle.perimeter());
    println!(&quot;Rectangle area: {}&quot;, rectangle.area());

    let mut square = Rectangle {
        p1: Point::origin(),
        p2: Point::new(1.0, 1.0),
    };

    // Error! `rectangle` is immutable, but this method requires a mutable
    // object
    //rectangle.translate(1.0, 0.0);
    // TODO ^ Try uncommenting this line

    // Okay! Mutable objects can call mutable methods
    square.translate(1.0, 1.0);

    let pair = Pair(Box::new(1), Box::new(2));

    pair.destroy();

    // Error! Previous `destroy` call &quot;consumed&quot; `pair`
    //pair.destroy();
    // TODO ^ Try uncommenting this line
}
</code></pre></pre>
<h2 id="exercises-3"><a class="header" href="#exercises-3">Exercises</a></h2>
<h3 id="method"><a class="header" href="#method">Method</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ Methods are similar to functions: declare with <code>fn</code>, have parameters and a return value.  Unlike functions, methods are defined within the context of a struct (or an enum or a trait object), and their first parameter is always <code>self</code>, which represents the instance of the struct the method is being called on.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    // complete the area method which return the area of a Rectangle
    fn area
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };

    assert_eq!(rect1.area(), 1500);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ <code>self</code> will take the ownership of current struct instance, however, <code>&amp;self</code> will only borrow a reference from the instance</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// Only fill in the blanks, DON'T remove any line!
#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    pub fn show_state(__)  {
        println!(&quot;the current state is {}&quot;, __.color);
    }
}
fn main() {
    let light = TrafficLight{
        color: &quot;red&quot;.to_owned(),
    };
    // Don't take the ownership of `light` here
    light.show_state();
    // ..otherwise, there will be an error below
    println!(&quot;{:?}&quot;, light);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ The <code>&amp;self</code> is actually short for <code>self: &amp;Self</code>. Within an <code>impl</code> block, the type <code>Self</code> is an alias for the type that the <code>impl</code> block is for. Methods must have a parameter named <code>self</code> of type <code>Self</code> for their first parameter, so Rust lets you abbreviate this with only the name <code>self</code> in the first parameter spot. </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct TrafficLight {
    color: String,
}

impl TrafficLight {
    // using `Self` to fill in the blank
    pub fn show_state(__)  {
        println!(&quot;the current state is {}&quot;, self.color);
    }

    // fill in the blank, DON'T use any variants of `Self`
    pub fn change_state() {
        self.color = &quot;green&quot;.to_string()
    }
}
fn main() {
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="associated-function"><a class="header" href="#associated-function">Associated function</a></h3>
<ol start="4">
<li>ğŸŒŸğŸŒŸ  All functions defined within an <code>impl</code> block are called associated functions because theyâ€™re associated with the type named after the <code>impl</code>. We can define associated functions that donâ€™t have <code>self</code> as their first parameter (and thus are not methods) because they donâ€™t need an instance of the type to work with.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
struct TrafficLight {
    color: String,
}

impl TrafficLight {
    // 1. implement a assotiated function `new`,
    // 2. it will return a TrafficLight contains color &quot;red&quot;
    // 3. must use `Self`, DONT use `TrafficLight` in fn signatures or body
    pub fn new() 

    pub fn get_state(&amp;self) -&gt; &amp;str {
        &amp;self.color
    }
}

fn main() {
    let light = TrafficLight::new();
    assert_eq!(light.get_state(), &quot;red&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="multiple-impl-blocks"><a class="header" href="#multiple-impl-blocks">Multiple <code>impl</code> blocks</a></h3>
<ol start="5">
<li>ğŸŒŸ Each struct is allowed to have multiple impl blocks. </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Rectangle {
    width: u32,
    height: u32,
}

// using multiple `impl` blocks to rewrite the code below
impl Rectangle {
    fn area(&amp;self) -&gt; u32 {
        self.width * self.height
    }

    fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool {
        self.width &gt; other.width &amp;&amp; self.height &gt; other.height
    }
}


fn main() {
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ We can also implement methods for enums.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
#[derive(Debug)]
enum TrafficLightColor {
    Red,
    Yellow,
    Green,
}

// implement TrafficLightColor with a method
impl TrafficLightColor {
    
}

fn main() {
    let c = TrafficLightColor::Yellow;

    assert_eq!(c.color(), &quot;yellow&quot;);

    println!(&quot;{:?}&quot;,c);
}
</code></pre></pre>
<h2 id="practice"><a class="header" href="#practice">Practice</a></h2>
<p>@todo</p>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics-and-traits"><a class="header" href="#generics-and-traits">Generics and Traits</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch10-00-generics.html">Rust Book 10.1, 10.2</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/trait/intro.html">Rustè¯­è¨€åœ£ç» - æ¨¡å¼åŒ¹é…</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="generics"><a class="header" href="#generics">Generics</a></h1>
<h3 id="functions-1"><a class="header" href="#functions-1">Functions</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks to make it work
struct A;          // Concrete type `A`.
struct S(A);       // Concrete type `S`.
struct SGen&lt;T&gt;(T); // Generic type `SGen`.

fn reg_fn(_s: S) {}

fn gen_spec_t(_s: SGen&lt;A&gt;) {}

fn gen_spec_i32(_s: SGen&lt;i32&gt;) {}

fn generic&lt;T&gt;(_s: SGen&lt;T&gt;) {}

fn main() {
    // Using the non-generic functions
    reg_fn(__);          // Concrete type.
    gen_spec_t(__);   // Implicitly specified type parameter `A`.
    gen_spec_i32(__); // Implicitly specified type parameter `i32`.

    // Explicitly specified type parameter `char` to `generic()`.
    generic::&lt;char&gt;(__);

    // Implicitly specified type parameter `char` to `generic()`.
    generic(__);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ A function call with explicitly specified type parameters looks like: <code>fun::&lt;A, B, ...&gt;()</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// implement the generic function below
fn sum

fn main() {
    assert_eq!(5, sum(2i8, 3i8));
    assert_eq!(50, sum(20, 30));
    assert_eq!(2.46, sum(1.23, 1.23));

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="struct-and-impl"><a class="header" href="#struct-and-impl">Struct and <code>impl</code></a></h3>
<ol start="3">
<li>ğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// implement struct Point to make it work


fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// modify this struct to make the code work
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

fn main() {
    // DON'T modify here
    let p = Point{x: 5, y : &quot;hello&quot;.to_string()};

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// add generic for Val to make the code work, DON'T modify the code in `main`
struct Val {
    val: f64,
}

impl Val {
    fn value(&amp;self) -&gt; &amp;f64 {
        &amp;self.val
    }
}


fn main() {
    let x = Val{ val: 3.0 };
    let y = Val{ val: &quot;hello&quot;.to_string()};
    println!(&quot;{}, {}&quot;, x.value(), y.value());
}
</code></pre></pre>
<h3 id="method-1"><a class="header" href="#method-1">Method</a></h3>
<ol start="6">
<li>ğŸŒŸğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Point&lt;T, U&gt; {
    x: T,
    y: U,
}

impl&lt;T, U&gt; Point&lt;T, U&gt; {
    // implement mixup to make it work, DON'T modify other code
    fn mixup
}

fn main() {
    let p1 = Point { x: 5, y: 10 };
    let p2 = Point { x: &quot;Hello&quot;, y: 'ä¸­'};

    let p3 = p1.mixup(p2);

    assert_eq!(p3.x, 5);
    assert_eq!(p3.y, 'ä¸­');

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors to make the code work
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

impl Point&lt;f32&gt; {
    fn distance_from_origin(&amp;self) -&gt; f32 {
        (self.x.powi(2) + self.y.powi(2)).sqrt()
    }
}

fn main() {
    let p = Point{x: 5, y: 10};
    println!(&quot;{}&quot;,p.distance_from_origin())
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="const-generics"><a class="header" href="#const-generics">Const Generics</a></h1>
<p>Const generics are generic arguments that range over constant values, rather than types or lifetimes. This allows, for instance, types to be parameterized by integers. In fact, there has been one example of const generic types since early on in Rust's development: the array types [T; N], for some type T and N: usize. However, there has previously been no way to abstract over arrays of an arbitrary size: if you wanted to implement a trait for arrays of any size, you would have to do so manually for each possible value. For a long time, even the standard library methods for arrays were limited to arrays of length at most 32 due to this problem.</p>
<h2 id="examples-2"><a class="header" href="#examples-2">Examples</a></h2>
<ol>
<li>Here's an example of a type and implementation making use of const generics: a type wrapping a pair of arrays of the same size.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct ArrayPair&lt;T, const N: usize&gt; {
    left: [T; N],
    right: [T; N],
}

impl&lt;T: Debug, const N: usize&gt; Debug for ArrayPair&lt;T, N&gt; {
    // ...
}
</code></pre></pre>
<ol start="2">
<li>Currently, const parameters may only be instantiated by const arguments of the following forms:</li>
</ol>
<ul>
<li>A standalone const parameter.</li>
<li>A literal (i.e. an integer, bool, or character).</li>
<li>A concrete constant expression (enclosed by {}), involving no generic parameters.</li>
</ul>
<pre><pre class="playground"><code class="language-rust editable edition2021">fn foo&lt;const N: usize&gt;() {}

fn bar&lt;T, const M: usize&gt;() {
    foo::&lt;M&gt;(); // ok: `M` is a const parameter
    foo::&lt;2021&gt;(); // ok: `2021` is a literal
    foo::&lt;{20 * 100 + 20 * 10 + 1}&gt;(); // ok: const expression contains no generic parameters
    
    foo::&lt;{ M + 1 }&gt;(); // error: const expression contains the generic parameter `M`
    foo::&lt;{ std::mem::size_of::&lt;T&gt;() }&gt;(); // error: const expression contains the generic parameter `T`
    
    let _: [u8; M]; // ok: `M` is a const parameter
    let _: [u8; std::mem::size_of::&lt;T&gt;()]; // error: const expression contains the generic parameter `T`
}

fn main() {}
</code></pre></pre>
<ol start="3">
<li>Const generics can also let us avoid some runtime checks.</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">/// A region of memory containing at least `N` `T`s.
pub struct MinSlice&lt;T, const N: usize&gt; {
    /// The bounded region of memory. Exactly `N` `T`s.
    pub head: [T; N],
    /// Zero or more remaining `T`s after the `N` in the bounded region.
    pub tail: [T],
}

fn main() {
    let slice: &amp;[u8] = b&quot;Hello, world&quot;;
    let reference: Option&lt;&amp;u8&gt; = slice.get(6);
    // We know this value is `Some(b' ')`,
    // but the compiler can't know that.
    assert!(reference.is_some());

    let slice: &amp;[u8] = b&quot;Hello, world&quot;;
    // Length check is performed when we construct a MinSlice,
    // and it's known at compile time to be of length 12.
    // If the `unwrap()` succeeds, no more checks are needed
    // throughout the `MinSlice`'s lifetime.
    let minslice = MinSlice::&lt;u8, 12&gt;::from_slice(slice).unwrap();
    let value: u8 = minslice.head[6];
    assert_eq!(value, b' ')
}
</code></pre></pre>
<h2 id="exercises-4"><a class="header" href="#exercises-4">Exercises</a></h2>
<ol>
<li>ğŸŒŸğŸŒŸ <code>&lt;T, const N: usize&gt;</code> is part of the struct type, it means <code>Array&lt;i32, 3&gt;</code> and <code>Array&lt;i32, 4&gt;</code> are different types.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">struct Array&lt;T, const N: usize&gt; {
    data : [T; N]
}

fn main() {
    let arrays = [
        Array{
            data: [1, 2, 3],
        },
        Array {
            data: [1.0, 2.0, 3.0],
        },
        Array {
            data: [1, 2]
        }
    ];

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ </li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks to make it work
fn print_array&lt;__&gt;(__) {
    println!(&quot;{:?}&quot;, arr);
}
fn main() {
    let arr = [1, 2, 3];
    print_array(arr);

    let arr = [&quot;hello&quot;, &quot;world&quot;];
    print_array(arr);
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ Sometimes we want to limit the size of an variable, e.g when using in embedding evironments, then <code>const expressions</code> will fit your need.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#![allow(incomplete_features)]
#![feature(generic_const_exprs)]

fn check_size&lt;T&gt;(val: T)
where
    Assert&lt;{ core::mem::size_of::&lt;T&gt;() &lt; 768 }&gt;: IsTrue,
{
    //...
}

// fix the errors in main
fn main() {
    check_size([0u8; 767]); 
    check_size([0i32; 191]);
    check_size([&quot;helloä½ å¥½&quot;; __]); // size of &amp;str ?
    check_size([&quot;helloä½ å¥½&quot;.to_string(); __]);  // size of String?
    check_size(['ä¸­'; __]); // size of char ?

    println!(&quot;Success!&quot;)
}



pub enum Assert&lt;const CHECK: bool&gt; {}

pub trait IsTrue {}

impl IsTrue for Assert&lt;true&gt; {}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it :)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>A trait tells the Rust compiler about functionality a particular type has and can share with other types. We can use traits to define shared behavior in an abstract way. We can use trait bounds to specify that a generic type can be any type that has certain behavior.</p>
<blockquote>
<p>Note: Traits are similar to interfaces in other languages, although with some differences.</p>
</blockquote>
<h2 id="examples-3"><a class="header" href="#examples-3">Examples</a></h2>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Sheep { naked: bool, name: String }

trait Animal {
    // Associated function signature; `Self` refers to the implementor type.
    fn new(name: String) -&gt; Self;

    // Method signatures; these will return a string.
    fn name(&amp;self) -&gt; String;
    
    fn noise(&amp;self) -&gt; String;

    // Traits can provide default method definitions.
    fn talk(&amp;self) {
        println!(&quot;{} says {}&quot;, self.name(), self.noise());
    }
}

impl Sheep {
    fn is_naked(&amp;self) -&gt; bool {
        self.naked
    }

    fn shear(&amp;mut self) {
        if self.is_naked() {
            // Implementor methods can use the implementor's trait methods.
            println!(&quot;{} is already naked...&quot;, self.name());
        } else {
            println!(&quot;{} gets a haircut!&quot;, self.name);

            self.naked = true;
        }
    }
}

// Implement the `Animal` trait for `Sheep`.
impl Animal for Sheep {
    // `Self` is the implementor type: `Sheep`.
    fn new(name: String) -&gt; Sheep {
        Sheep { name: name, naked: false }
    }

    fn name(&amp;self) -&gt; String {
        self.name.clone()
    }

    fn noise(&amp;self) -&gt; String {
        if self.is_naked() {
            &quot;baaaaah?&quot;.to_string()
        } else {
            &quot;baaaaah!&quot;.to_string()
        }
    }
    
    // Default trait methods can be overridden.
    fn talk(&amp;self) {
        // For example, we can add some quiet contemplation.
        println!(&quot;{} pauses briefly... {}&quot;, self.name, self.noise());
    }
}

fn main() {
    // Type annotation is necessary in this case.
    let mut dolly: Sheep = Animal::new(&quot;Dolly&quot;.to_string());
    // TODO ^ Try removing the type annotations.

    dolly.talk();
    dolly.shear();
    dolly.talk();
}
</code></pre></pre>
<h2 id="exercises-5"><a class="header" href="#exercises-5">Exercises</a></h2>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the two impl blocks to make the code work
// DON'T modify the code in `main`
trait Hello {
    fn say_hi(&amp;self) -&gt; String {
        String::from(&quot;hi&quot;)
    }

    fn say_something(&amp;self) -&gt; String;
}

struct Student {}
impl Hello for Student {
}
struct Teacher {}
impl Hello for Teacher {
}

fn main() {
    let s = Student {};
    assert_eq!(s.say_hi(), &quot;hi&quot;);
    assert_eq!(s.say_something(), &quot;I'm a good student&quot;);

    let t = Teacher {};
    assert_eq!(t.say_hi(), &quot;Hi, I'm your new teacher&quot;);
    assert_eq!(t.say_something(), &quot;I'm not a bad teacher&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="derive"><a class="header" href="#derive">Derive</a></h3>
<p>The compiler is capable of providing basic implementations for some traits via
the <code>#[derive]</code> attribute. For more info, please visit <a href="https://doc.rust-lang.org/book/appendix-03-derivable-traits.html">here</a>.</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// `Centimeters`, a tuple struct that can be compared
#[derive(PartialEq, PartialOrd)]
struct Centimeters(f64);

// `Inches`, a tuple struct that can be printed
#[derive(Debug)]
struct Inches(i32);

impl Inches {
    fn to_centimeters(&amp;self) -&gt; Centimeters {
        let &amp;Inches(inches) = self;

        Centimeters(inches as f64 * 2.54)
    }
}

// ADD some attributes to make the code work!
// DON'T modify other codes!
struct Seconds(i32);

fn main() {
    let _one_second = Seconds(1);

    println!(&quot;One second looks like: {:?}&quot;, _one_second);
    let _this_is_true = (_one_second == _one_second);
    let _this_is_true = (_one_second &gt; _one_second);

    let foot = Inches(12);

    println!(&quot;One foot equals {:?}&quot;, foot);

    let meter = Centimeters(100.0);

    let cmp =
        if foot.to_centimeters() &lt; meter {
            &quot;smaller&quot;
        } else {
            &quot;bigger&quot;
        };

    println!(&quot;One foot is {} than one meter.&quot;, cmp);
}
</code></pre></pre>
<h3 id="operator"><a class="header" href="#operator">Operator</a></h3>
<p>In Rust, many of the operators can be overloaded via traits. That is, some operators can be used to accomplish different tasks based on their input arguments. This is possible because operators are syntactic sugar for method calls. For example, the + operator in a + b calls the add method (as in a.add(b)). This add method is part of the Add trait. Hence, the + operator can be used by any implementor of the Add trait.</p>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::ops;

// implement fn multiply to make the code work
// As mentiond above, `+` needs `T` to implement `std::ops::Add` Trait
// so, what about `*` ?  You can find the answer here: https://doc.rust-lang.org/core/ops/
fn multipl

fn main() {
    assert_eq!(6, multiply(2u8, 3u8));
    assert_eq!(5.0, multiply(1.0, 5.0));

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fix the errors, DON'T modify the code in `main`
use std::ops;

struct Foo;
struct Bar;

struct FooBar;

struct BarFoo;

// The `std::ops::Add` trait is used to specify the functionality of `+`.
// Here, we make `Add&lt;Bar&gt;` - the trait for addition with a RHS of type `Bar`.
// The following block implements the operation: Foo + Bar = FooBar
impl ops::Add&lt;Bar&gt; for Foo {
    type Output = FooBar;

    fn add(self, _rhs: Bar) -&gt; FooBar {
        FooBar
    }
}

impl ops::Sub&lt;Foo&gt; for Bar {
    type Output = BarFoo;

    fn sub(self, _rhs: Foo) -&gt; BarFoo {
        BarFoo
    }
}

fn main() {
    // DON'T modify the below code
    // you need to derive some trait for FooBar to make it comparable
    assert_eq!(Foo + Bar, FooBar);
    assert_eq!(Foo - Bar, BarFoo);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="use-trait-as-function-parameters"><a class="header" href="#use-trait-as-function-parameters">Use trait as function parameters</a></h3>
<p>Instead of a concrete type for the item parameter, we specify the impl keyword and the trait name. This parameter accepts any type that implements the specified trait. </p>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// implement `fn summary` to make the code work
// fix the errors without removing any code line
trait Summary {
    fn summarize(&amp;self) -&gt; String;
}

#[derive(Debug)]
struct Post {
    title: String,
    author: String,
    content: String,
}

impl Summary for Post {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;The author of post {} is {}&quot;, self.title, self.author)
    }
}

#[derive(Debug)]
struct Weibo {
    username: String,
    content: String,
}

impl Summary for Weibo {
    fn summarize(&amp;self) -&gt; String {
        format!(&quot;{} published a weibo {}&quot;, self.username, self.content)
    }
}

fn main() {
    let post = Post {
        title: &quot;Popular Rust&quot;.to_string(),
        author: &quot;Sunface&quot;.to_string(),
        content: &quot;Rust is awesome!&quot;.to_string(),
    };
    let weibo = Weibo {
        username: &quot;sunface&quot;.to_string(),
        content: &quot;Weibo seems to be worse than Tweet&quot;.to_string(),
    };

    summary(post);
    summary(weibo);

    println!(&quot;{:?}&quot;, post);
    println!(&quot;{:?}&quot;, weibo);
}

// implement `fn summary` below

</code></pre></pre>
<h3 id="returning-types-that-implement-traits"><a class="header" href="#returning-types-that-implement-traits">Returning Types that Implement Traits</a></h3>
<p>We can also use the impl Trait syntax in the return position to return a value of some type that implements a trait.</p>
<p>However, you can only use impl Trait if youâ€™re returning a single type, using Trait Objects instead when you really need to return serveral types.</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Sheep {}
struct Cow {}

trait Animal {
    fn noise(&amp;self) -&gt; String;
}

impl Animal for Sheep {
    fn noise(&amp;self) -&gt; String {
        &quot;baaaaah!&quot;.to_string()
    }
}

impl Animal for Cow {
    fn noise(&amp;self) -&gt; String {
        &quot;moooooo!&quot;.to_string()
    }
}

// Returns some struct that implements Animal, but we don't know which one at compile time.
// FIX the erros here, you can make a fake random, or you can use trait object
fn random_animal(random_number: f64) -&gt; impl Animal {
    if random_number &lt; 0.5 {
        Sheep {}
    } else {
        Cow {}
    }
}

fn main() {
    let random_number = 0.234;
    let animal = random_animal(random_number);
    println!(&quot;You've randomly chosen an animal, and it says {}&quot;, animal.noise());
}
</code></pre></pre>
<h3 id="trait-bound"><a class="header" href="#trait-bound">Trait bound</a></h3>
<p>The <code>impl Trait</code> syntax works for straightforward cases but is actually syntax sugar for a longer form, which is called a trait bound.</p>
<p>When working with generics, the type parameters often must use traits as bounds to stipulate what functionality a type implements. </p>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust  editable edition2021">fn main() {
    assert_eq!(sum(1, 2), 3);
}

// implement `fn sum` with trait bound in two ways
fn sum&lt;T&gt;(x: T, y: T) -&gt; T {
    x + y
}
</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FIX the errors
struct Pair&lt;T&gt; {
    x: T,
    y: T,
}

impl&lt;T&gt; Pair&lt;T&gt; {
    fn new(x: T, y: T) -&gt; Self {
        Self {
            x,
            y,
        }
    }
}

impl&lt;T: std::fmt::Debug + PartialOrd&gt; Pair&lt;T&gt; {
    fn cmp_display(&amp;self) {
        if self.x &gt;= self.y {
            println!(&quot;The largest member is x = {:?}&quot;, self.x);
        } else {
            println!(&quot;The largest member is y = {:?}&quot;, self.y);
        }
    }
}

struct Unit(i32);

fn main() {
    let pair = Pair{
        x: Unit(1),
        y: Unit(3)
    };

    pair.cmp_display();
}
</code></pre></pre>
<ol start="9">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// fill in the blanks to make it work
fn example1() {
    // `T: Trait` is the commonly used way
    // `T: Fn(u32) -&gt; u32` specifies that we can only pass a closure to `T`
    struct Cacher&lt;T: Fn(u32) -&gt; u32&gt; {
        calculation: T,
        value: Option&lt;u32&gt;,
    }

    impl&lt;T: Fn(u32) -&gt; u32&gt; Cacher&lt;T&gt; {
        fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
            Cacher {
                calculation,
                value: None,
            }
        }

        fn value(&amp;mut self, arg: u32) -&gt; u32 {
            match self.value {
                Some(v) =&gt; v,
                None =&gt; {
                    let v = (self.calculation)(arg);
                    self.value = Some(v);
                    v
                },
            }
        }
    }

    let mut cacher = Cacher::new(|x| x+1);
    assert_eq!(cacher.value(10), __);
    assert_eq!(cacher.value(15), __);
}


fn example2() {
    // We can also use `where` to constrain `T`
    struct Cacher&lt;T&gt;
        where T: Fn(u32) -&gt; u32,
    {
        calculation: T,
        value: Option&lt;u32&gt;,
    }

    impl&lt;T&gt; Cacher&lt;T&gt;
        where T: Fn(u32) -&gt; u32,
    {
        fn new(calculation: T) -&gt; Cacher&lt;T&gt; {
            Cacher {
                calculation,
                value: None,
            }
        }

        fn value(&amp;mut self, arg: u32) -&gt; u32 {
            match self.value {
                Some(v) =&gt; v,
                None =&gt; {
                    let v = (self.calculation)(arg);
                    self.value = Some(v);
                    v
                },
            }
        }
    }

    let mut cacher = Cacher::new(|x| x+1);
    assert_eq!(cacher.value(20), __);
    assert_eq!(cacher.value(25), __);
}



fn main() {
    example1();
    example2();

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it :)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="trait-object"><a class="header" href="#trait-object">Trait Object</a></h1>
<p>In <a href="https://practice.rs/generics-traits/traits.html#returning-types-that-implement-traits">traits chapter</a> we have seen that we can't use <code>impl Trait</code> when returning multiple types.</p>
<p>Also one limitation of arrays is that they can only store elements of one type, yeah, enum is a not bad solution when our items are a fixed set of types in compile time, but trait object are more flexible and powerful here.</p>
<h2 id="returning-traits-with-dyn"><a class="header" href="#returning-traits-with-dyn">Returning Traits with dyn</a></h2>
<p>The Rust compiler needs to know how much space a function's return type requires. Because the different implementations of a trait probably will need different amounts of memoery, this means function need to return a concrete type or the same type when using  <code>impl Trait</code>, or it can return a trait object with <code>dyn</code>.</p>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Bird {
    fn quack(&amp;self) -&gt; String;
}

struct Duck;
impl Duck {
    fn swim(&amp;self) {
        println!(&quot;Look, the duck is swimming&quot;)
    }
}
struct Swan;
impl Swan {
    fn fly(&amp;self) {
        println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;)
    }
}

impl Bird for Duck {
    fn quack(&amp;self) -&gt; String{
        &quot;duck duck&quot;.to_string()
    }
}

impl Bird for Swan {
    fn quack(&amp;self) -&gt; String{
        &quot;swan swan&quot;.to_string()
    }
}

fn main() {
    // FILL in the blank
    let duck = __;
    duck.swim();

    let bird = hatch_a_bird(2);
    // this bird has forgotten how to swim, so below line will cause an error
    // bird.swim();
    // but it can quak
    assert_eq!(bird.quack(), &quot;duck duck&quot;);

    let bird = hatch_a_bird(1);
    // this bird has forgotten how to fly, so below line will cause an error
    // bird.fly();
    // but it can quak too
    assert_eq!(bird.quack(), &quot;swan swan&quot;);

    println!(&quot;Success!&quot;)
}   

// IMPLEMENT this function
fn hatch_a_bird...

</code></pre></pre>
<h2 id="array-with-trait-objects"><a class="header" href="#array-with-trait-objects">Array with trait objects</a></h2>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Bird {
    fn quack(&amp;self);
}

struct Duck;
impl Duck {
    fn fly(&amp;self) {
        println!(&quot;Look, the duck is flying&quot;)
    }
}
struct Swan;
impl Swan {
    fn fly(&amp;self) {
        println!(&quot;Look, the duck.. oh sorry, the swan is flying&quot;)
    }
}

impl Bird for Duck {
    fn quack(&amp;self) {
        println!(&quot;{}&quot;, &quot;duck duck&quot;);
    }
}

impl Bird for Swan {
    fn quack(&amp;self) {
        println!(&quot;{}&quot;, &quot;swan swan&quot;);
    }
}

fn main() {
    // FILL in the blank to make the code work
    let birds __;

    for bird in birds {
        bird.quack();
        // when duck and swan turns into Bird, they all forgot how to fly, only remeber how to quack
        // so, the below code will cause an error
        // bird.fly();
    }
}
</code></pre></pre>
<h2 id="dyn-and-boxdyn"><a class="header" href="#dyn-and-boxdyn"><code>&amp;dyn</code> and <code>Box&lt;dyn&gt;</code></a></h2>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FILL in the blanks
trait Draw {
    fn draw(&amp;self) -&gt; String;
}

impl Draw for u8 {
    fn draw(&amp;self) -&gt; String {
        format!(&quot;u8: {}&quot;, *self)
    }
}

impl Draw for f64 {
    fn draw(&amp;self) -&gt; String {
        format!(&quot;f64: {}&quot;, *self)
    }
}

fn main() {
    let x = 1.1f64;
    let y = 8u8;

    // draw x
    draw_with_box(__);

    // draw y
    draw_with_ref(&amp;y);

    println!(&quot;Success!&quot;)
}

fn draw_with_box(x: Box&lt;dyn Draw&gt;) {
    x.draw();
}

fn draw_with_ref(x: __) {
    x.draw();
}
</code></pre></pre>
<h2 id="static-and-dynamic-dispatch"><a class="header" href="#static-and-dynamic-dispatch">Static and Dynamic dispatch</a></h2>
<p>when we use trait bounds on generics: the compiler generates nongeneric implementations of functions and methods for each concrete type that we use in place of a generic type parameter. The code that results from monomorphization is doing static dispatch, which is when the compiler knows what method youâ€™re calling at compile time. </p>
<p>When we use trait objects, Rust must use dynamic dispatch. The compiler doesnâ€™t know all the types that might be used with the code that is using trait objects, so it doesnâ€™t know which method implemented on which type to call. Instead, at runtime, Rust uses the pointers inside the trait object to know which method to call. There is a runtime cost when this lookup happens that doesnâ€™t occur with static dispatch. Dynamic dispatch also prevents the compiler from choosing to inline a methodâ€™s code, which in turn prevents some optimizations. </p>
<p>However, we did get extra flexibility when using dynamic dispatch.</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Foo {
    fn method(&amp;self) -&gt; String;
}

impl Foo for u8 {
    fn method(&amp;self) -&gt; String { format!(&quot;u8: {}&quot;, *self) }
}

impl Foo for String {
    fn method(&amp;self) -&gt; String { format!(&quot;string: {}&quot;, *self) }
}

// IMPLEMENT below with generics
fn static_dispatch...

// implement below with trait objects
fn dynamic_dispatch...

fn main() {
    let x = 5u8;
    let y = &quot;Hello&quot;.to_string();

    static_dispatch(x);
    dynamic_dispatch(&amp;y);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h2 id="object-safe"><a class="header" href="#object-safe">Object safe</a></h2>
<p>You can only make object-safe traits into trait objects. A trait is object safe if all the methods defined in the trait have the following properties:</p>
<ul>
<li>The return type isnâ€™t <code>Self</code>.</li>
<li>There are no generic type parameters.</li>
</ul>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// Use at least two approaches to make it work
// DON'T add/remove any code line
trait MyTrait {
    fn f(&amp;self) -&gt; Self;
}

impl MyTrait for u32 {
    fn f(&amp;self) -&gt; Self { 42 }
}

impl MyTrait for String {
    fn f(&amp;self) -&gt; Self { self.clone() }
}

fn my_function(x: Box&lt;dyn MyTrait&gt;)  {
    x.f()
}

fn main() {
    my_function(Box::new(13_u32));
    my_function(Box::new(String::from(&quot;abc&quot;)));

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it :)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advance-traits"><a class="header" href="#advance-traits">Advance Traits</a></h1>
<h2 id="associated-types"><a class="header" href="#associated-types">Associated types</a></h2>
<p>The use of &quot;Associated types&quot; improves the overall readability of code by moving inner types locally into a trait as output types. For example :</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait CacheableItem: Clone + Default + fmt::Debug + Decodable + Encodable {
  type Address: AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash;
  fn is_null(&amp;self) -&gt; bool;
}
<span class="boring">}
</span></code></pre></pre>
<p>Using of <code>Address</code> is much more clearable and convenient than <code>AsRef&lt;[u8]&gt; + Clone + fmt::Debug + Eq + Hash</code>.</p>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
struct Container(i32, i32);

// USING associated types to re-implement trait Contains.
// trait Contains {
//    type A;
//    type B;

trait Contains&lt;A, B&gt; {
    fn contains(&amp;self, _: &amp;A, _: &amp;B) -&gt; bool;
    fn first(&amp;self) -&gt; i32;
    fn last(&amp;self) -&gt; i32;
}

impl Contains&lt;i32, i32&gt; for Container {
    fn contains(&amp;self, number_1: &amp;i32, number_2: &amp;i32) -&gt; bool {
        (&amp;self.0 == number_1) &amp;&amp; (&amp;self.1 == number_2)
    }
    // Grab the first number.
    fn first(&amp;self) -&gt; i32 { self.0 }

    // Grab the last number.
    fn last(&amp;self) -&gt; i32 { self.1 }
}

fn difference&lt;A, B, C: Contains&lt;A, B&gt;&gt;(container: &amp;C) -&gt; i32 {
    container.last() - container.first()
}

fn main() {
    let number_1 = 3;
    let number_2 = 10;

    let container = Container(number_1, number_2);

    println!(&quot;Does container contain {} and {}: {}&quot;,
        &amp;number_1, &amp;number_2,
        container.contains(&amp;number_1, &amp;number_2));
    println!(&quot;First number: {}&quot;, container.first());
    println!(&quot;Last number: {}&quot;, container.last());
    
    println!(&quot;The difference is: {}&quot;, difference(&amp;container));
}
</code></pre></pre>
<h2 id="default-generic-type-parameters"><a class="header" href="#default-generic-type-parameters">Default Generic Type Parameters</a></h2>
<p>When we use generic type parameters, we can specify a default concrete type for the generic type. This eliminates the need for implementors of the trait to specify a concrete type if the default type works.</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::ops::Sub;

#[derive(Debug, PartialEq)]
struct Point&lt;T&gt; {
    x: T,
    y: T,
}

// FILL in the blank in three ways: two of them use the default generic  parameters, the other one not.
// Notice that the implementation uses the associated type `Output`.
impl __ {
    type Output = Self;

    fn sub(self, other: Self) -&gt; Self::Output {
        Point {
            x: self.x - other.x,
            y: self.y - other.y,
        }
    }
}

fn main() {
    assert_eq!(Point { x: 2, y: 3 } - Point { x: 1, y: 0 },
        Point { x: 1, y: 3 });

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h2 id="fully-qualified-syntax"><a class="header" href="#fully-qualified-syntax">Fully Qualified Syntax</a></h2>
<p>Nothing in Rust prevents a trait from having a method with the same name as another traitâ€™s method, nor does Rust prevent you from implementing both traits on one type. Itâ€™s also possible to implement a method directly on the type with the same name as methods from traits.</p>
<p>When calling methods with the same name, we have to use  Fully Qualified Syntax.</p>
<h4 id="example-2"><a class="header" href="#example-2">Example</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait UsernameWidget {
    // Get the selected username out of this widget
    fn get(&amp;self) -&gt; String;
}

trait AgeWidget {
    // Get the selected age out of this widget
    fn get(&amp;self) -&gt; u8;
}

// A form with both a UsernameWidget and an AgeWidget
struct Form {
    username: String,
    age: u8,
}

impl UsernameWidget for Form {
    fn get(&amp;self) -&gt; String {
        self.username.clone()
    }
}

impl AgeWidget for Form {
    fn get(&amp;self) -&gt; u8 {
        self.age
    }
}

fn main() {
    let form = Form{
        username: &quot;rustacean&quot;.to_owned(),
        age: 28,
    };

    // If you uncomment this line, you'll get an error saying 
    // &quot;multiple `get` found&quot;. Because, after all, there are multiple methods
    // named `get`.
    // println!(&quot;{}&quot;, form.get());
    
    let username = UsernameWidget::get(&amp;form);
    assert_eq!(&quot;rustacean&quot;.to_owned(), username);
    let age = AgeWidget::get(&amp;form); // you can also use `&lt;Form as AgeWidget&gt;::get`
    assert_eq!(28, age);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h4 id="exercise"><a class="header" href="#exercise">Exercise</a></h4>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait Pilot {
    fn fly(&amp;self) -&gt; String;
}

trait Wizard {
    fn fly(&amp;self) -&gt; String;
}

struct Human;

impl Pilot for Human {
    fn fly(&amp;self) -&gt; String {
        String::from(&quot;This is your captain speaking.&quot;)
    }
}

impl Wizard for Human {
    fn fly(&amp;self) -&gt; String {
        String::from(&quot;Up!&quot;)
    }
}

impl Human {
    fn fly(&amp;self) -&gt; String {
        String::from(&quot;*waving arms furiously*&quot;)
    }
}

fn main() {
    let person = Human;

    assert_eq!(__, &quot;This is your captain speaking.&quot;);
    assert_eq!(__, &quot;Up!&quot;);

    assert_eq!(__, &quot;*waving arms furiously*&quot;);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h2 id="supertraits"><a class="header" href="#supertraits">Supertraits</a></h2>
<p>Sometimes, you might need one trait to use another traitâ€™s functionality( like the &quot;inheritance&quot; in other languages ). In this case, you need to rely on the dependent trait also being implemented. The trait you rely on is a <code>supertrait</code> of the trait youâ€™re implementing.</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
trait Person {
    fn name(&amp;self) -&gt; String;
}

// Person is a supertrait of Student.
// Implementing Student requires you to also impl Person.
trait Student: Person {
    fn university(&amp;self) -&gt; String;
}

trait Programmer {
    fn fav_language(&amp;self) -&gt; String;
}

// CompSciStudent (computer science student) is a subtrait of both Programmer 
// and Student. Implementing CompSciStudent requires you to impl both supertraits.
trait CompSciStudent: Programmer + Student {
    fn git_username(&amp;self) -&gt; String;
}

fn comp_sci_student_greeting(student: &amp;dyn CompSciStudent) -&gt; String {
    format!(
        &quot;My name is {} and I attend {}. My favorite language is {}. My Git username is {}&quot;,
        student.name(),
        student.university(),
        student.fav_language(),
        student.git_username()
    )
}

struct CSStudent {
    name: String,
    university: String,
    fav_language: String,
    git_username: String
}

// IMPLEMENT the necessary traits for CSStudent to make the code work
impl ...

fn main() {
    let student = CSStudent {
        name: &quot;Sunfei&quot;.to_string(),
        university: &quot;XXX&quot;.to_string(),
        fav_language: &quot;Rust&quot;.to_string(),
        git_username: &quot;sunface&quot;.to_string()
    };

    // FILL in the blank
    println!(&quot;{}&quot;, comp_sci_student_greeting(__));
}
</code></pre></pre>
<h2 id="orphan-rules"><a class="header" href="#orphan-rules">Orphan Rules</a></h2>
<p>We canâ€™t implement external traits on external types. For example, we canâ€™t implement the <code>Display</code> trait on <code>Vec&lt;T&gt;</code> within our own crate, because <code>Display</code> and <code>Vec&lt;T&gt;</code> are defined in the standard library and arenâ€™t local to our crate. </p>
<p>This restriction is often called as the orphan rule, so named because the parent type is not present. This rule ensures that other peopleâ€™s code canâ€™t break your code and vice versa. </p>
<p>Itâ€™s possible to get around this restriction using the newtype pattern, which involves creating a new type in a tuple struct.</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust edition2021">use std::fmt;

// DEFINE a newtype `Pretty` here


impl fmt::Display for Pretty {
    fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
        write!(f, &quot;\&quot;{}\&quot;&quot;, self.0.clone() + &quot;, world&quot;)
    }
}

fn main() {
    let w = Pretty(&quot;hello&quot;.to_string());
    println!(&quot;w = {}&quot;, w);
}
</code></pre></pre>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it :)</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="collection-types"><a class="header" href="#collection-types">Collection Types</a></h1>
<p>Learning resources: </p>
<ul>
<li>English: <a href="https://doc.rust-lang.org/book/ch08-00-common-collections.html">Rust Book Chapter 8</a></li>
<li>ç®€ä½“ä¸­æ–‡: <a href="https://course.rs/basic/collections/intro.html">Rustè¯­è¨€åœ£ç» - é›†åˆç±»å‹</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-2"><a class="header" href="#string-2">String</a></h1>
<p><code>std::string::String</code> is a UTF-8 encoded, growable string. It is the most common string type we used in daily dev, it also has ownership over the string contents.</p>
<h3 id="basic-operations"><a class="header" href="#basic-operations">Basic operations</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FILL in the blanks and FIX errors
// 1. Don't use `to_string()`
// 2. Dont't add/remove any code line
fn main() {
    let mut s: String = &quot;hello, &quot;;
    s.push_str(&quot;world&quot;.to_string());
    s.push(__);

    move_ownership(s);

    assert_eq!(s, &quot;hello, world!&quot;);

    println!(&quot;Success!&quot;)
}

fn move_ownership(s: String) {
    println!(&quot;ownership of \&quot;{}\&quot; is moved here!&quot;, s)
}
</code></pre></pre>
<h3 id="string-and-str"><a class="header" href="#string-and-str">String and &amp;str</a></h3>
<p>A <code>String</code> is stored as a vector of bytes (<code>Vec&lt;u8&gt;</code>), but guaranteed to always be a valid UTF-8 sequence. <code>String</code> is heap allocated, growable and not null terminated.</p>
<p><code>&amp;str</code> is a slice (<code>&amp;[u8]</code>) that always points to a valid UTF-8 sequence, and can be used to view into a String, just like <code>&amp;[T]</code> is a view into <code>Vec&lt;T&gt;</code>.</p>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// FILL in the blanks
fn main() {  
   // get a slice of String with reference: String -&gt; &amp;str 
   let mut s = String::from(&quot;hello, world&quot;);

   let slice1: &amp;str = __; // in two ways
   assert_eq!(slice1, &quot;hello, world&quot;);

   let slice2 = __;
   assert_eq!(slice2, &quot;hello&quot;);

   let slice3: __ = __; 
   slice3.push('!');
   assert_eq!(slice3, &quot;hello, world!&quot;);

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// Question: how many heap allocations are happend here ?
// Your answer: 
fn main() {  
    // Create a String type based on `&amp;str`
    // the type of string literals is `&amp;str`
   let s: String = String::from(&quot;hello, world!&quot;);

   // create a slice point to String `s`
   let slice: &amp;str = &amp;s;

   // create a String type based on the recently created slice
   let s: String = slice.to_string();

   assert_eq!(s, &quot;hello, world!&quot;);

   println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="utf-8--indexing"><a class="header" href="#utf-8--indexing">UTF-8 &amp; Indexing</a></h3>
<p>Strings are always valid UTF-8. This has a few implications:</p>
<ul>
<li>the first of which is that if you need a non-UTF-8 string, consider <a href="https://doc.rust-lang.org/stable/std/ffi/struct.OsString.html">OsString</a>. It is similar, but without the UTF-8 constraint. </li>
<li>The second implication is that you cannot index into a String</li>
</ul>
<p>Indexing is intended to be a constant-time operation, but UTF-8 encoding does not allow us to do this. Furthermore, itâ€™s not clear what sort of thing the index should return: a byte, a codepoint, or a grapheme cluster. The bytes and chars methods return iterators over the first two, respectively.</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ You can't use index to access a char in a string, but you can use slice <code>&amp;s1[start..end]</code>.</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FILL in the blank and FIX errors
fn main() {
    let s = String::from(&quot;hello, ä¸–ç•Œ&quot;);
    let slice1 = s[0]; //tips: `h` only takes 1 byte in UTF8 format
    assert_eq!(slice1, &quot;h&quot;);

    let slice2 = &amp;s[3..5];// tips: `ä¸­`  takes 3 bytes in UTF8 format
    assert_eq!(slice2, &quot;ä¸–&quot;);
    
    // iterate all chars in s
    for (i, c) in s.__ {
        if i == 7 {
            assert_eq!(c, 'ä¸–')
        }
    }

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h4 id="utf8_slice-1"><a class="header" href="#utf8_slice-1">utf8_slice</a></h4>
<p>You can use <a href="https://docs.rs/utf8_slice/1.0.0/utf8_slice/fn.slice.html">utf8_slice</a> to slice UTF8 string, it can index chars instead of bytes.</p>
<p><strong>Example</strong></p>
<pre><pre class="playground"><code class="language-rust edition2021">use utf_slice;
fn main() {
   let s = &quot;The ğŸš€ goes to the ğŸŒ‘!&quot;;

   let rocket = utf8_slice::slice(s, 4, 5);
   // Will equal &quot;ğŸš€&quot;
}
</code></pre></pre>
<ol start="5">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<blockquote>
<p>Tips: maybe you need <code>from_utf8</code> method</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FILL in the blanks
fn main() {
    let mut s = String::new();
    __;

    // some bytes, in a vector
    let v = vec![104, 101, 108, 108, 111];

    // Turn a bytes vector into a String
    // We know these bytes are valid, so we'll use `unwrap()`.
    let s1 = __;
    
    
    assert_eq!(s, s1);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="representation"><a class="header" href="#representation">Representation</a></h3>
<p>A String is made up of three components: a pointer to some bytes, a length, and a capacity. </p>
<p>The pointer points to an internal buffer String uses to store its data. The length is the number of bytes currently stored in the buffer( always stored on the heap ), and the capacity is the size of the buffer in bytes. As such, the length will always be less than or equal to the capacity.</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸ If a String has enough capacity, adding elements to it will not re-allocate</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// modify the code below to print out: 
// 25
// 25
// 25
// Here, thereâ€™s no need to allocate more memory inside the loop.
fn main() {
    let mut s = String::new();

    println!(&quot;{}&quot;, s.capacity());

    for _ in 0..2 {
        s.push_str(&quot;hello&quot;);
        println!(&quot;{}&quot;, s.capacity());
    }

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="7">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FILL in the blanks
use std::mem;

fn main() {
    let story = String::from(&quot;Rust By Practice&quot;);

    // Prevent automatically dropping the String's data
    let mut story = mem::ManuallyDrop::new(story);

    let ptr = story.__();
    let len = story.__();
    let capacity = story.__();

    // story has nineteen bytes
    assert_eq!(16, len);

    // We can re-build a String out of ptr, len, and capacity. This is all
    // unsafe because we are responsible for making sure the components are
    // valid:
    let s = unsafe { String::from_raw_parts(ptr, len, capacity) };

    assert_eq!(*story, s);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="common-methods"><a class="header" href="#common-methods">Common methods</a></h3>
<p>More exercises of String methods can be found <a href="collections/../std/String.html">here</a>.</p>
<blockquote>
<p>You can find the solutions <a href="https://github.com/sunface/rust-by-practice">here</a>(under the solutions path), but only use it when you need it</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vector"><a class="header" href="#vector">Vector</a></h1>
<p>Vectors are re-sizable arrays. Like slices, their size is not known at compile time, but they can grow or shrink at any time. </p>
<h3 id="basic-operations-1"><a class="header" href="#basic-operations-1">Basic Operations</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
fn main() {
    let arr: [u8; 3] = [1, 2, 3];
    
    let v = Vec::from(arr);
    is_vec(v);

    let v = vec![1, 2, 3];
    is_vec(v);

    // vec!(..) and vec![..] are same macros, so
    let v = vec!(1, 2, 3);
    is_vec(v);
    
    // in code below, v is Vec&lt;[u8; 3]&gt; , not Vec&lt;u8&gt;
    // USE Vec::new and `for` to rewrite the below code 
    let v1 = vec!(arr);
    is_vec(v1);
 
    assert_eq!(v, v1);

    println!(&quot;Success!&quot;)
}

fn is_vec(v: Vec&lt;u8&gt;) {}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ a Vec can be extended with <code>extend</code> method</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FILL in the blank
fn main() {
    let mut v1 = Vec::from([1, 2, 4]);
    v1.pop();
    v1.push(3);
    
    let mut v2 = Vec::new();
    v2.__;

    assert_eq!(v1, v2);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="turn-x-into-vec"><a class="header" href="#turn-x-into-vec">Turn X Into Vec</a></h3>
<ol start="3">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FILL in the blanks
fn main() {
    // array -&gt; Vec
    // impl From&lt;[T; N]&gt; for Vec
    let arr = [1, 2, 3];
    let v1 = __(arr);
    let v2: Vec&lt;i32&gt; = arr.__();
 
    assert_eq!(v1, v2);
 
    
    // String -&gt; Vec
    // impl From&lt;String&gt; for Vec
    let s = &quot;hello&quot;.to_string();
    let v1: Vec&lt;u8&gt; = s.__();

    let s = &quot;hello&quot;.to_string();
    let v2 = s.into_bytes();
    assert_eq!(v1, v2);

    // impl&lt;'_&gt; From&lt;&amp;'_ str&gt; for Vec
    let s = &quot;hello&quot;;
    let v3 = Vec::__(s);
    assert_eq!(v2, v3);

    // Iterators can be collected into vectors
    let v4: Vec&lt;i32&gt; = [0; 10].into_iter().collect();
    assert_eq!(v4, vec![0; 10]);

    println!(&quot;Success!&quot;)
 }
</code></pre></pre>
<h3 id="indexing"><a class="header" href="#indexing">Indexing</a></h3>
<ol start="4">
<li>ğŸŒŸğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FIX the error and IMPLEMENT the code
fn main() {
    let mut v = Vec::from([1, 2, 3]);
    for i in 0..5 {
        println!(&quot;{:?}&quot;, v[i])
    }

    for i in 0..5 {
       // IMPLEMENT the code here...
    }
    
    assert_eq!(v, vec![2, 3, 4, 5, 6]);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="slicing"><a class="header" href="#slicing">Slicing</a></h3>
<p>A Vec can be mutable. On the other hand, slices are read-only objects. To get a slice, use <code>&amp;</code>. </p>
<p>In Rust, itâ€™s more common to pass slices as arguments rather than vectors when you just want to provide read access. The same goes for <code>String</code> and <code>&amp;str</code>.</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FIX the errors
fn main() {
    let mut v = vec![1, 2, 3];

    let slice1 = &amp;v[..];
    // out of bounds will cause a panic
    // You must use `v.len` here
    let slice2 = &amp;v[0..4];
    
    assert_eq!(slice1, slice2);
    
    // slice are read only
    // Note: slice and &amp;Vec are different
    let vec_ref: &amp;mut Vec&lt;i32&gt; = &amp;mut v;
    (*vec_ref).push(4);
    let slice3 = &amp;mut v[0..3];
    slice3.push(4);

    assert_eq!(slice3, &amp;[1, 2, 3, 4]);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="capacity"><a class="header" href="#capacity">Capacity</a></h3>
<p>The capacity of a vector is the amount of space allocated for any future elements that will be added onto the vector. This is not to be confused with the length of a vector, which specifies the number of actual elements within the vector. If a vectorâ€™s length exceeds its capacity, its capacity will automatically be increased, but its elements will have to be reallocated.</p>
<p>For example, a vector with capacity 10 and length 0 would be an empty vector with space for 10 more elements. Pushing 10 or fewer elements onto the vector will not change its capacity or cause reallocation to occur. However, if the vectorâ€™s length is increased to 11, it will have to reallocate, which can be slow. For this reason, it is recommended to use <code>Vec::with_capacity </code>whenever possible to specify how big the vector is expected to get.</p>
<ol start="6">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// FIX the errors
fn main() {
    let mut vec = Vec::with_capacity(10);

    // The vector contains no items, even though it has capacity for more
    assert_eq!(vec.len(), __);
    assert_eq!(vec.capacity(), 10);

    // These are all done without reallocating...
    for i in 0..10 {
        vec.push(i);
    }
    assert_eq!(vec.len(), __);
    assert_eq!(vec.capacity(), __);

    // ...but this may make the vector reallocate
    vec.push(11);
    assert_eq!(vec.len(), 11);
    assert!(vec.capacity() &gt;= 11);


    // fill in an appropriate value to make the `for` done without reallocating 
    let mut vec = Vec::with_capacity(__);
    for i in 0..100 {
        vec.push(i);
    }

    assert_eq!(vec.len(), __);
    assert_eq!(vec.capacity(), __);
    
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="store-distinct-types-in-vector"><a class="header" href="#store-distinct-types-in-vector">Store distinct types in Vector</a></h3>
<p>The elements in a vector mush be the same type, for example , the code below will cause an error:</p>
<pre><pre class="playground"><code class="language-rust edition2021">fn main() {
   let v = vec![1, 2.0, 3];
}
</code></pre></pre>
<p>But we can use enums or trait objects to store distinct types.</p>
<ol start="7">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">#[derive(Debug)]
enum IpAddr {
    V4(String),
    V6(String),
}
fn main() {
    // FILL in the blank
    let v : Vec&lt;IpAddr&gt;= __;
    
    // Comparing two enums need to derive the PartialEq trait
    assert_eq!(v[0], IpAddr::V4(&quot;127.0.0.1&quot;.to_string()));
    assert_eq!(v[1], IpAddr::V6(&quot;::1&quot;.to_string()));

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="8">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">trait IpAddr {
    fn display(&amp;self);
}

struct V4(String);
impl IpAddr for V4 {
    fn display(&amp;self) {
        println!(&quot;ipv4: {:?}&quot;,self.0)
    }
}
struct V6(String);
impl IpAddr for V6 {
    fn display(&amp;self) {
        println!(&quot;ipv6: {:?}&quot;,self.0)
    }
}

fn main() {
    // FILL in the blank
    let v: __= vec![
        Box::new(V4(&quot;127.0.0.1&quot;.to_string())),
        Box::new(V6(&quot;::1&quot;.to_string())),
    ];

    for ip in v {
        ip.display();
    }
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h1>
<p>Where vectors store values by an integer index, HashMaps store values by key. It is a hash map implemented with quadratic probing and SIMD lookup. By default, <code>HashMap</code> uses a hashing algorithm selected to provide resistance against HashDoS attacks.</p>
<p>The default hashing algorithm is currently <code>SipHash 1-3</code>, though this is subject to change at any point in the future. While its performance is very competitive for medium sized keys, other hashing algorithms will outperform it for small keys such as integers as well as large keys such as long strings, though those algorithms will typically not protect against attacks such as HashDoS.</p>
<p>The hash table implementation is a Rust port of Googleâ€™s <a href="https://abseil.io/blog/20180927-swisstables">SwissTable</a>. The original C++ version of SwissTable can be found <a href="https://github.com/abseil/abseil-cpp/blob/master/absl/container/internal/raw_hash_set.h">here</a>, and this <a href="https://www.youtube.com/watch?v=ncHmEUmJZf4">CppCon talk</a> gives an overview of how the algorithm works.</p>
<h3 id="basic-operations-2"><a class="header" href="#basic-operations-2">Basic Operations</a></h3>
<ol>
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editbale edition2021">// FILL in the blanks and FIX the erros
use std::collections::HashMap;
fn main() {
    let mut scores = HashMap::new();
    scores.insert(&quot;Sunface&quot;, 98);
    scores.insert(&quot;Daniel&quot;, 95);
    scores.insert(&quot;Ashley&quot;, 69.0);
    scores.insert(&quot;Katie&quot;, &quot;58&quot;);

    // get returns a Option&lt;&amp;V&gt;
    let score = scores.get(&quot;Sunface&quot;);
    assert_eq!(score, Some(98));

    if scores.contains_key(&quot;Daniel&quot;) {
        // indexing return a value V
        let score = scores[&quot;Daniel&quot;];
        assert_eq!(score, __);
        scores.remove(&quot;Daniel&quot;);
    }

    assert_eq!(scores.len(), __);

    for (name, score) in scores {
        println!(&quot;The score of {} is {}&quot;, name, score)
    }
}
</code></pre></pre>
<ol start="2">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::collections::HashMap;
fn main() {
    let teams = [
        (&quot;Chinese Team&quot;, 100),
        (&quot;American Team&quot;, 10),
        (&quot;France Team&quot;, 50),
    ];

    let mut teams_map1 = HashMap::new();
    for team in &amp;teams {
        teams_map1.insert(team.0, team.1);
    }

    // IMPLEMENT team_map2 in two ways
    // tips: one of the approaches is to use `collect` method
    let teams_map2...

    assert_eq!(teams_map1, teams_map2);

    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<ol start="3">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FILL in the blanks
use std::collections::HashMap;
fn main() {
    // type inference lets us omit an explicit type signature (which
    // would be `HashMap&lt;&amp;str, u8&gt;` in this example).
    let mut player_stats = HashMap::new();

    // insert a key only if it doesn't already exist
    player_stats.entry(&quot;health&quot;).or_insert(100);

    assert_eq!(player_stats[&quot;health&quot;], __);

    // insert a key using a function that provides a new value only if it
    // doesn't already exist
    player_stats.entry(&quot;health&quot;).or_insert_with(random_stat_buff);
    assert_eq!(player_stats[&quot;health&quot;], __);

    // Ensures a value is in the entry by inserting the default if empty, and returns
    // a mutable reference to the value in the entry.
    let health = player_stats.entry(&quot;health&quot;).or_insert(50);
    assert_eq!(health, __);
    *health -= 50;
    assert_eq!(*health, __);

    println!(&quot;Success!&quot;)
}

fn random_stat_buff() -&gt; u8 {
    // could actually return some random value here - let's just return
    // some fixed value for now
    42
}
</code></pre></pre>
<h3 id="requirements-of-hashmap-key"><a class="header" href="#requirements-of-hashmap-key">Requirements of HashMap key</a></h3>
<p>Any type that implements the <code>Eq</code> and <code>Hash</code> traits can be a key in <code>HashMap</code>. This includes:</p>
<ul>
<li><code>bool</code> (though not very useful since there is only two possible keys)</li>
<li><code>int</code>, <code>uint</code>, and all variations thereof</li>
<li><code>String</code> and <code>&amp;str</code> (tips: you can have a <code>HashMap</code> keyed by <code>String</code> and call <code>.get()</code> with an <code>&amp;str</code>)</li>
</ul>
<p>Note that <code>f32</code> and <code>f64</code> do not implement <code>Hash</code>, likely because <a href="https://en.wikipedia.org/wiki/Floating-point_arithmetic#Accuracy_problems">floating-point precision</a> errors would make using them as hashmap keys horribly error-prone.</p>
<p>All collection classes implement <code>Eq</code> and <code>Hash</code> if their contained type also respectively implements <code>Eq</code> and <code>Hash</code>. For example, <code>Vec&lt;T&gt;</code> will implement <code>Hash</code> if <code>T</code>implements <code>Hash</code>.</p>
<ol start="4">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">
// FIX the errors
// Tips: `derive` is usually a good way to implement some common used traits
use std::collections::HashMap;

struct Viking {
    name: String,
    country: String,
}

impl Viking {
    /// Creates a new Viking.
    fn new(name: &amp;str, country: &amp;str) -&gt; Viking {
        Viking {
            name: name.to_string(),
            country: country.to_string(),
        }
    }
}

fn main() {
    // Use a HashMap to store the vikings' health points.
    let vikings = HashMap::from([
        (Viking::new(&quot;Einar&quot;, &quot;Norway&quot;), 25),
        (Viking::new(&quot;Olaf&quot;, &quot;Denmark&quot;), 24),
        (Viking::new(&quot;Harald&quot;, &quot;Iceland&quot;), 12),
    ]);

    // Use derived implementation to print the status of the vikings.
    for (viking, health) in &amp;vikings {
        println!(&quot;{:?} has {} hp&quot;, viking, health);
    }
}
</code></pre></pre>
<h3 id="capacity-1"><a class="header" href="#capacity-1">Capacity</a></h3>
<p>Like vectors, HashMaps are growable, but HashMaps can also shrink themselves when they have excess space. You can create a <code>HashMap</code> with a certain starting capacity using <code>HashMap::with_capacity(uint)</code>, or use <code>HashMap::new()</code> to get a HashMap with a default initial capacity (recommended).</p>
<h4 id="example-3"><a class="header" href="#example-3">Example</a></h4>
<pre><pre class="playground"><code class="language-rust editable edition2021">
use std::collections::HashMap;
fn main() {
    let mut map: HashMap&lt;i32, i32&gt; = HashMap::with_capacity(100);
    map.insert(1, 2);
    map.insert(3, 4);
    // indeed ,the capacity of HashMap is not 100, so we can't compare the equality here.
    assert!(map.capacity() &gt;= 100);

    // Shrinks the capacity of the map with a lower limit. It will drop
    // down no lower than the supplied limit while maintaining the internal rules
    // and possibly leaving some space in accordance with the resize policy.

    map.shrink_to(50);
    assert!(map.capacity() &gt;= 50);

    // Shrinks the capacity of the map as much as possible. It will drop
    // down as much as possible while maintaining the internal rules
    // and possibly leaving some space in accordance with the resize policy.
    map.shrink_to_fit();
    assert!(map.capacity() &gt;= 2);
    println!(&quot;Success!&quot;)
}
</code></pre></pre>
<h3 id="ownership-1"><a class="header" href="#ownership-1">Ownership</a></h3>
<p>For types that implement the <code>Copy</code> trait, like <code>i32</code> , the values are copied into <code>HashMap</code>. For owned values like <code>String</code>, the values will be moved and <code>HashMap</code> will be the owner of those values.</p>
<ol start="5">
<li>ğŸŒŸğŸŒŸ</li>
</ol>
<pre><pre class="playground"><code class="language-rust editable edition2021">// FIX the errors with least changes
// DON'T remove any code line
use std::collections::HashMap;
fn main() {
  let v1 = 10;
  let mut m1 = HashMap::new();
  m1.insert(v1, v1);
  println!(&quot;v1 is still usable after inserting to hashmap : {}&quot;, v1);

  let v2 = &quot;hello&quot;.to_string();
  let mut m2 = HashMap::new();
  // ownership moved here
  m2.insert(v2, v1);
    
  assert_eq!(v2, &quot;hello&quot;);
}
</code></pre></pre>
<h3 id="third-party-hash-libs"><a class="header" href="#third-party-hash-libs">Third-party Hash libs</a></h3>
<p>If the performance of <code>SipHash 1-3</code> doesn't meet your requirements, you can find replacements in crates.io or github.com.</p>
<p>The usage of third-party hash looks like this:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::hash::BuildHasherDefault;
use std::collections::HashMap;
// introduce a third party hash function
use twox_hash::XxHash64;


let mut hash: HashMap&lt;_, _, BuildHasherDefault&lt;XxHash64&gt;&gt; = Default::default();
hash.insert(42, &quot;the answer&quot;);
assert_eq!(hash.get(&amp;42), Some(&amp;&quot;the answer&quot;));
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-conversion"><a class="header" href="#type-conversion">Type Conversion</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-panic"><a class="header" href="#result-and-panic">Result and panic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="panic"><a class="header" href="#panic">panic!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="result-and-"><a class="header" href="#result-and-">result and ?</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate-and-module"><a class="header" href="#crate-and-module">Crate and module</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="crate"><a class="header" href="#crate">Crate</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="module"><a class="header" href="#module">Module</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="use-and-pub"><a class="header" href="#use-and-pub">use and pub</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-and-docs"><a class="header" href="#comments-and-docs">Comments and Docs</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="formatted-output"><a class="header" href="#formatted-output">Formatted output</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lifetime"><a class="header" href="#lifetime">Lifetime</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h2 id="ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤"><a class="header" href="#ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤">ç”Ÿå‘½å‘¨æœŸæ¶ˆé™¤</a></h2>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn print(s: &amp;str);                                      // elided
fn print&lt;'a&gt;(s: &amp;'a str);                               // expanded

fn debug(lvl: usize, s: &amp;str);                          // elided
fn debug&lt;'a&gt;(lvl: usize, s: &amp;'a str);                   // expanded

fn substr(s: &amp;str, until: usize) -&gt; &amp;str;               // elided
fn substr&lt;'a&gt;(s: &amp;'a str, until: usize) -&gt; &amp;'a str;     // expanded

fn get_str() -&gt; &amp;str;                                   // ILLEGAL

fn frob(s: &amp;str, t: &amp;str) -&gt; &amp;str;                      // ILLEGAL

fn get_mut(&amp;mut self) -&gt; &amp;mut T;                        // elided
fn get_mut&lt;'a&gt;(&amp;'a mut self) -&gt; &amp;'a mut T;              // expanded

fn args&lt;T: ToCStr&gt;(&amp;mut self, args: &amp;[T]) -&gt; &amp;mut Command                  // elided
fn args&lt;'a, 'b, T: ToCStr&gt;(&amp;'a mut self, args: &amp;'b [T]) -&gt; &amp;'a mut Command // expanded

fn new(buf: &amp;mut [u8]) -&gt; BufWriter;                    // elided
fn new(buf: &amp;mut [u8]) -&gt; BufWriter&lt;'_&gt;;                // elided (with `rust_2018_idioms`)
fn new&lt;'a&gt;(buf: &amp;'a mut [u8]) -&gt; BufWriter&lt;'a&gt;          // expanded
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="static-and-t-static"><a class="header" href="#static-and-t-static">&amp;'static and T: 'static</a></h1>
<pre><pre class="playground"><code class="language-rust editable edition2021">use std::fmt::Display;

fn main() {
  let mut string = &quot;First&quot;.to_owned();

  string.push_str(string.to_uppercase().as_str());
  print_a(&amp;string);
  print_b(&amp;string);
  print_c(&amp;string); // Compilation error
  print_d(&amp;string); // Compilation error
  print_e(&amp;string);
  print_f(&amp;string);
  print_g(&amp;string); // Compilation error
}

fn print_a&lt;T: Display + 'static&gt;(t: &amp;T) {
  println!(&quot;{}&quot;, t);
}

fn print_b&lt;T&gt;(t: &amp;T)
where
  T: Display + 'static,
{
  println!(&quot;{}&quot;, t);
}

fn print_c(t: &amp;'static dyn Display) {
  println!(&quot;{}&quot;, t)
}

fn print_d(t: &amp;'static impl Display) {
  println!(&quot;{}&quot;, t)
}

fn print_e(t: &amp;(dyn Display + 'static)) {
  println!(&quot;{}&quot;, t)
}

fn print_f(t: &amp;(impl Display + 'static)) {
  println!(&quot;{}&quot;, t)
}

fn print_g(t: &amp;'static String) {
  println!(&quot;{}&quot;, t);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advance"><a class="header" href="#advance">advance</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functional-programing"><a class="header" href="#functional-programing">Functional programing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="closure"><a class="header" href="#closure">Closure</a></h1>
<p>ä¸‹é¢ä»£ç æ˜¯Ruståœ£ç»è¯¾ç¨‹ä¸­<a href="http://course.rs/advance/functional-programing/closure.html#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85">é—­åŒ…</a>ç« èŠ‚çš„è¯¾å†…ç»ƒä¹ é¢˜ç­”æ¡ˆï¼š</p>
<pre><pre class="playground"><code class="language-rust edition2021">struct Cacher&lt;T,E&gt;
where
    T: Fn(E) -&gt; E,
    E: Copy
{
    query: T,
    value: Option&lt;E&gt;,
}

impl&lt;T,E&gt; Cacher&lt;T,E&gt;
where
    T: Fn(E) -&gt; E,
    E: Copy
{
    fn new(query: T) -&gt; Cacher&lt;T,E&gt; {
        Cacher {
            query,
            value: None,
        }
    }

    fn value(&amp;mut self, arg: E) -&gt; E {
        match self.value {
            Some(v) =&gt; v,
            None =&gt; {
                let v = (self.query)(arg);
                self.value = Some(v);
                v
            }
        }
    }
}
fn main() {
  
}

#[test]
fn call_with_different_values() {
    let mut c = Cacher::new(|a| a);

    let v1 = c.value(1);
    let v2 = c.value(2);

    assert_eq!(v2, 1);
}
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="iterator"><a class="header" href="#iterator">Iterator</a></h1>
<p>https://doc.rust-lang.org/stable/rust-by-example/flow_control/for.html#for-and-iterators</p>
<pre><pre class="playground"><code class="language-rust editable edition2021">// (all the type annotations are superfluous)
// A reference to a string allocated in read only memory
let pangram: &amp;'static str = &quot;the quick brown fox jumps over the lazy dog&quot;;
println!(&quot;Pangram: {}&quot;, pangram);

// Iterate over words in reverse, no new string is allocated
println!(&quot;Words in reverse&quot;);
for word in pangram.split_whitespace().rev() {
    println!(&quot;&gt; {}&quot;, word);
}

// Copy chars into a vector, sort and remove duplicates
let mut chars: Vec&lt;char&gt; = pangram.chars().collect();
chars.sort();
chars.dedup();
</code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="newtype-and-sized"><a class="header" href="#newtype-and-sized">newtype and Sized</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="smart-pointers"><a class="header" href="#smart-pointers">Smart pointers</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="box"><a class="header" href="#box">Box</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="deref"><a class="header" href="#deref">Deref</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="drop"><a class="header" href="#drop">Drop</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rc-and-arc"><a class="header" href="#rc-and-arc">Rc and Arc</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cell-and-refcell"><a class="header" href="#cell-and-refcell">Cell and RefCell</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="weak-and-circle-reference"><a class="header" href="#weak-and-circle-reference">Weak and Circle reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="self-referential"><a class="header" href="#self-referential">Self referential</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-using"><a class="header" href="#basic-using">Basic using</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="message-passing"><a class="header" href="#message-passing">Message passing</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sync"><a class="header" href="#sync">Sync</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="atomic"><a class="header" href="#atomic">Atomic</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="send-and-sync"><a class="header" href="#send-and-sync">Send and Sync</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="global-variables"><a class="header" href="#global-variables">Global variables</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="errors"><a class="header" href="#errors">Errors</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unsafe-todo"><a class="header" href="#unsafe-todo">Unsafe todo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="inline-assembly"><a class="header" href="#inline-assembly">Inline assembly</a></h1>
<p>Rust provides support for inline assembly via the <code>asm!</code> macro.
It can be used to embed handwritten assembly in the assembly output generated by the compiler.
Generally this should not be necessary, but might be where the required performance or timing
cannot be otherwise achieved. Accessing low level hardware primitives, e.g. in kernel code, may also demand this functionality.</p>
<blockquote>
<p><strong>Note</strong>: the examples here are given in x86/x86-64 assembly, but other architectures are also supported.</p>
</blockquote>
<p>Inline assembly is currently supported on the following architectures:</p>
<ul>
<li>x86 and x86-64</li>
<li>ARM</li>
<li>AArch64</li>
<li>RISC-V</li>
</ul>
<h2 id="basic-usage"><a class="header" href="#basic-usage">Basic usage</a></h2>
<p>Let us start with the simplest possible example:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

unsafe {
    asm!(&quot;nop&quot;);
}
<span class="boring">}
</span></code></pre></pre>
<p>This will insert a NOP (no operation) instruction into the assembly generated by the compiler.
Note that all <code>asm!</code> invocations have to be inside an <code>unsafe</code> block, as they could insert
arbitrary instructions and break various invariants. The instructions to be inserted are listed
in the first argument of the <code>asm!</code> macro as a string literal.</p>
<h2 id="inputs-and-outputs"><a class="header" href="#inputs-and-outputs">Inputs and outputs</a></h2>
<p>Now inserting an instruction that does nothing is rather boring. Let us do something that
actually acts on data:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let x: u64;
unsafe {
    asm!(&quot;mov {}, 5&quot;, out(reg) x);
}
assert_eq!(x, 5);
<span class="boring">}
</span></code></pre></pre>
<p>This will write the value <code>5</code> into the <code>u64</code> variable <code>x</code>.
You can see that the string literal we use to specify instructions is actually a template string.
It is governed by the same rules as Rust <a href="https://doc.rust-lang.org/std/fmt/#syntax">format strings</a>.
The arguments that are inserted into the template however look a bit different than you may
be familiar with. First we need to specify if the variable is an input or an output of the
inline assembly. In this case it is an output. We declared this by writing <code>out</code>.
We also need to specify in what kind of register the assembly expects the variable.
In this case we put it in an arbitrary general purpose register by specifying <code>reg</code>.
The compiler will choose an appropriate register to insert into
the template and will read the variable from there after the inline assembly finishes executing.</p>
<p>Let us see another example that also uses an input:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let i: u64 = 3;
let o: u64;
unsafe {
    asm!(
        &quot;mov {0}, {1}&quot;,
        &quot;add {0}, 5&quot;,
        out(reg) o,
        in(reg) i,
    );
}
assert_eq!(o, 8);
<span class="boring">}
</span></code></pre></pre>
<p>This will add <code>5</code> to the input in variable <code>i</code> and write the result to variable <code>o</code>.
The particular way this assembly does this is first copying the value from <code>i</code> to the output,
and then adding <code>5</code> to it.</p>
<p>The example shows a few things:</p>
<p>First, we can see that <code>asm!</code> allows multiple template string arguments; each
one is treated as a separate line of assembly code, as if they were all joined
together with newlines between them. This makes it easy to format assembly
code.</p>
<p>Second, we can see that inputs are declared by writing <code>in</code> instead of <code>out</code>.</p>
<p>Third, we can see that we can specify an argument number, or name as in any format string.
For inline assembly templates this is particularly useful as arguments are often used more than once.
For more complex inline assembly using this facility is generally recommended, as it improves
readability, and allows reordering instructions without changing the argument order.</p>
<p>We can further refine the above example to avoid the <code>mov</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut x: u64 = 3;
unsafe {
    asm!(&quot;add {0}, 5&quot;, inout(reg) x);
}
assert_eq!(x, 8);
<span class="boring">}
</span></code></pre></pre>
<p>We can see that <code>inout</code> is used to specify an argument that is both input and output.
This is different from specifying an input and output separately in that it is guaranteed to assign both to the same register.</p>
<p>It is also possible to specify different variables for the input and output parts of an <code>inout</code> operand:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let x: u64 = 3;
let y: u64;
unsafe {
    asm!(&quot;add {0}, 5&quot;, inout(reg) x =&gt; y);
}
assert_eq!(y, 8);
<span class="boring">}
</span></code></pre></pre>
<h2 id="late-output-operands"><a class="header" href="#late-output-operands">Late output operands</a></h2>
<p>The Rust compiler is conservative with its allocation of operands. It is assumed that an <code>out</code>
can be written at any time, and can therefore not share its location with any other argument.
However, to guarantee optimal performance it is important to use as few registers as possible,
so they won't have to be saved and reloaded around the inline assembly block.
To achieve this Rust provides a <code>lateout</code> specifier. This can be used on any output that is
written only after all inputs have been consumed.
There is also a <code>inlateout</code> variant of this specifier.</p>
<p>Here is an example where <code>inlateout</code> <em>cannot</em> be used:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
let c: u64 = 4;
unsafe {
    asm!(
        &quot;add {0}, {1}&quot;,
        &quot;add {0}, {2}&quot;,
        inout(reg) a,
        in(reg) b,
        in(reg) c,
    );
}
assert_eq!(a, 12);
<span class="boring">}
</span></code></pre></pre>
<p>Here the compiler is free to allocate the same register for inputs <code>b</code> and <code>c</code> since it knows they have the same value. However it must allocate a separate register for <code>a</code> since it uses <code>inout</code> and not <code>inlateout</code>. If <code>inlateout</code> was used, then <code>a</code> and <code>c</code> could be allocated to the same register, in which case the first instruction to overwrite the value of <code>c</code> and cause the assembly code to produce the wrong result.</p>
<p>However the following example can use <code>inlateout</code> since the output is only modified after all input registers have been read:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(&quot;add {0}, {1}&quot;, inlateout(reg) a, in(reg) b);
}
assert_eq!(a, 8);
<span class="boring">}
</span></code></pre></pre>
<p>As you can see, this assembly fragment will still work correctly if <code>a</code> and <code>b</code> are assigned to the same register.</p>
<h2 id="explicit-register-operands"><a class="header" href="#explicit-register-operands">Explicit register operands</a></h2>
<p>Some instructions require that the operands be in a specific register.
Therefore, Rust inline assembly provides some more specific constraint specifiers.
While <code>reg</code> is generally available on any architecture, explicit registers are highly architecture specific. E.g. for x86 the general purpose registers <code>eax</code>, <code>ebx</code>, <code>ecx</code>, <code>edx</code>, <code>ebp</code>, <code>esi</code>, and <code>edi</code> among others can be addressed by their name.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let cmd = 0xd1;
unsafe {
    asm!(&quot;out 0x64, eax&quot;, in(&quot;eax&quot;) cmd);
}
<span class="boring">}
</span></code></pre></pre>
<p>In this example we call the <code>out</code> instruction to output the content of the <code>cmd</code> variable to port <code>0x64</code>. Since the <code>out</code> instruction only accepts <code>eax</code> (and its sub registers) as operand we had to use the <code>eax</code> constraint specifier.</p>
<blockquote>
<p><strong>Note</strong>: unlike other operand types, explicit register operands cannot be used in the template string: you can't use <code>{}</code> and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.</p>
</blockquote>
<p>Consider this example which uses the x86 <code>mul</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

fn mul(a: u64, b: u64) -&gt; u128 {
    let lo: u64;
    let hi: u64;

    unsafe {
        asm!(
            // The x86 mul instruction takes rax as an implicit input and writes
            // the 128-bit result of the multiplication to rax:rdx.
            &quot;mul {}&quot;,
            in(reg) a,
            inlateout(&quot;rax&quot;) b =&gt; lo,
            lateout(&quot;rdx&quot;) hi
        );
    }

    ((hi as u128) &lt;&lt; 64) + lo as u128
}
<span class="boring">}
</span></code></pre></pre>
<p>This uses the <code>mul</code> instruction to multiply two 64-bit inputs with a 128-bit result.
The only explicit operand is a register, that we fill from the variable <code>a</code>.
The second operand is implicit, and must be the <code>rax</code> register, which we fill from the variable <code>b</code>.
The lower 64 bits of the result are stored in <code>rax</code> from which we fill the variable <code>lo</code>.
The higher 64 bits are stored in <code>rdx</code> from which we fill the variable <code>hi</code>.</p>
<h2 id="clobbered-registers"><a class="header" href="#clobbered-registers">Clobbered registers</a></h2>
<p>In many cases inline assembly will modify state that is not needed as an output.
Usually this is either because we have to use a scratch register in the assembly or because instructions modify state that we don't need to further examine.
This state is generally referred to as being &quot;clobbered&quot;.
We need to tell the compiler about this since it may need to save and restore this state around the inline assembly block.</p>
<pre><pre class="playground"><code class="language-rust edition2021">use core::arch::asm;

fn main() {
    // three entries of four bytes each
    let mut name_buf = [0_u8; 12];
    // String is stored as ascii in ebx, edx, ecx in order
    // Because ebx is reserved, we get a scratch register and move from
    // ebx into it in the asm.  The asm needs to preserve the value of
    // that register though, so it is pushed and popped around the main asm
    // (in 64 bit mode for 64 bit processors, 32 bit processors would use ebx)

    unsafe {
        asm!(
            &quot;push rbx&quot;,
            &quot;cpuid&quot;,
            &quot;mov [{0}], ebx&quot;,
            &quot;mov [{0} + 4], edx&quot;,
            &quot;mov [{0} + 8], ecx&quot;,
            &quot;pop rbx&quot;,
            // We use a pointer to an array for storing the values to simplify
            // the Rust code at the cost of a couple more asm instructions
            // This is more explicit with how the asm works however, as opposed
            // to explicit register outputs such as `out(&quot;ecx&quot;) val`
            // The *pointer itself* is only an input even though it's written behind
            in(reg) name_buf.as_mut_ptr(),
            // select cpuid 0, also specify eax as clobbered
            inout(&quot;eax&quot;) 0 =&gt; _,
            // cpuid clobbers these registers too
            out(&quot;ecx&quot;) _,
            out(&quot;edx&quot;) _,
        );
    }

    let name = core::str::from_utf8(&amp;name_buf).unwrap();
    println!(&quot;CPU Manufacturer ID: {}&quot;, name);
}
</code></pre></pre>
<p>In the example above we use the <code>cpuid</code> instruction to read the CPU manufacturer ID.
This instruction writes to <code>eax</code> with the maximum supported <code>cpuid</code> argument and <code>ebx</code>, <code>esx</code>, and <code>ecx</code> with the CPU manufacturer ID as ASCII bytes in that order.</p>
<p>Even though <code>eax</code> is never read we still need to tell the compiler that the register has been modified so that the compiler can save any values that were in these registers before the asm. This is done by declaring it as an output but with <code>_</code> instead of a variable name, which indicates that the output value is to be discarded.</p>
<p>This code also works around the limitation that <code>ebx</code> is a reserved register by LLVM. That means that LLVM assumes that it has full control over the register and it must be restored to its original state before exiting the asm block, so it cannot be used as an output. To work around this we save the register via <code>push</code>, read from <code>ebx</code> inside the asm block into a temporary register allocated with <code>out(reg)</code> and then restoring <code>ebx</code> to its original state via <code>pop</code>. The <code>push</code> and <code>pop</code> use the full 64-bit <code>rbx</code> version of the register to ensure that the entire register is saved. On 32 bit targets the code would instead use <code>ebx</code> in the <code>push</code>/<code>pop</code>.</p>
<p>This can also be used with a general register class (e.g. <code>reg</code>) to obtain a scratch register for use inside the asm code:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

// Multiply x by 6 using shifts and adds
let mut x: u64 = 4;
unsafe {
    asm!(
        &quot;mov {tmp}, {x}&quot;,
        &quot;shl {tmp}, 1&quot;,
        &quot;shl {x}, 2&quot;,
        &quot;add {x}, {tmp}&quot;,
        x = inout(reg) x,
        tmp = out(reg) _,
    );
}
assert_eq!(x, 4 * 6);
<span class="boring">}
</span></code></pre></pre>
<h2 id="symbol-operands-and-abi-clobbers"><a class="header" href="#symbol-operands-and-abi-clobbers">Symbol operands and ABI clobbers</a></h2>
<p>By default, <code>asm!</code> assumes that any register not specified as an output will have its contents preserved by the assembly code. The <a href="unsafe/../../reference/inline-assembly.html#abi-clobbers"><code>clobber_abi</code></a> argument to <code>asm!</code> tells the compiler to automatically insert the necessary clobber operands according to the given calling convention ABI: any register which is not fully preserved in that ABI will be treated as clobbered.  Multiple <code>clobber_abi</code> arguments may be provided and all clobbers from all specified ABIs will be inserted.</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

extern &quot;C&quot; fn foo(arg: i32) -&gt; i32 {
    println!(&quot;arg = {}&quot;, arg);
    arg * 2
}

fn call_foo(arg: i32) -&gt; i32 {
    unsafe {
        let result;
        asm!(
            &quot;call *{}&quot;,
            // Function pointer to call
            in(reg) foo,
            // 1st argument in rdi
            in(&quot;rdi&quot;) arg,
            // Return value in rax
            out(&quot;rax&quot;) result,
            // Mark all registers which are not preserved by the &quot;C&quot; calling
            // convention as clobbered.
            clobber_abi(&quot;C&quot;),
        );
        result
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="register-template-modifiers"><a class="header" href="#register-template-modifiers">Register template modifiers</a></h2>
<p>In some cases, fine control is needed over the way a register name is formatted when inserted into the template string. This is needed when an architecture's assembly language has several names for the same register, each typically being a &quot;view&quot; over a subset of the register (e.g. the low 32 bits of a 64-bit register).</p>
<p>By default the compiler will always choose the name that refers to the full register size (e.g. <code>rax</code> on x86-64, <code>eax</code> on x86, etc).</p>
<p>This default can be overriden by using modifiers on the template string operands, just like you would with format strings:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut x: u16 = 0xab;

unsafe {
    asm!(&quot;mov {0:h}, {0:l}&quot;, inout(reg_abcd) x);
}

assert_eq!(x, 0xabab);
<span class="boring">}
</span></code></pre></pre>
<p>In this example, we use the <code>reg_abcd</code> register class to restrict the register allocator to the 4 legacy x86 registers (<code>ax</code>, <code>bx</code>, <code>cx</code>, <code>dx</code>) of which the first two bytes can be addressed independently.</p>
<p>Let us assume that the register allocator has chosen to allocate <code>x</code> in the <code>ax</code> register.
The <code>h</code> modifier will emit the register name for the high byte of that register and the <code>l</code> modifier will emit the register name for the low byte. The asm code will therefore be expanded as <code>mov ah, al</code> which copies the low byte of the value into the high byte.</p>
<p>If you use a smaller data type (e.g. <code>u16</code>) with an operand and forget the use template modifiers, the compiler will emit a warning and suggest the correct modifier to use.</p>
<h2 id="memory-address-operands"><a class="header" href="#memory-address-operands">Memory address operands</a></h2>
<p>Sometimes assembly instructions require operands passed via memory addresses/memory locations.
You have to manually use the memory address syntax specified by the target architecture.
For example, on x86/x86_64 using Intel assembly syntax, you should wrap inputs/outputs in <code>[]</code> to indicate they are memory operands:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

fn load_fpu_control_word(control: u16) {
    unsafe {
        asm!(&quot;fldcw [{}]&quot;, in(reg) &amp;control, options(nostack));
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="labels"><a class="header" href="#labels">Labels</a></h2>
<p>Any reuse of a named label, local or otherwise, can result in an assembler or linker error or may cause other strange behavior. Reuse of a named label can happen in a variety of ways including:</p>
<ul>
<li>explicitly: using a label more than once in one <code>asm!</code> block, or multiple times across blocks.</li>
<li>implicitly via inlining: the compiler is allowed to instantiate multiple copies of an <code>asm!</code> block, for example when the function containing it is inlined in multiple places.</li>
<li>implicitly via LTO: LTO can cause code from <em>other crates</em> to be placed in the same codegen unit, and so could bring in arbitrary labels.</li>
</ul>
<p>As a consequence, you should only use GNU assembler <strong>numeric</strong> <a href="https://sourceware.org/binutils/docs/as/Symbol-Names.html#Local-Labels">local labels</a> inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.</p>
<p>Moreover, on x86 when using the default Intel syntax, due to <a href="https://bugs.llvm.org/show_bug.cgi?id=36144">an LLVM bug</a>, you shouldn't use labels exclusively made of <code>0</code> and <code>1</code> digits, e.g. <code>0</code>, <code>11</code> or <code>101010</code>, as they may end up being interpreted as binary values. Using <code>options(att_syntax)</code> will avoid any ambiguity, but that affects the syntax of the <em>entire</em> <code>asm!</code> block. (See <a href="unsafe/inline-asm.html#options">Options</a>, below, for more on <code>options</code>.)</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a = 0;
unsafe {
    asm!(
        &quot;mov {0}, 10&quot;,
        &quot;2:&quot;,
        &quot;sub {0}, 1&quot;,
        &quot;cmp {0}, 3&quot;,
        &quot;jle 2f&quot;,
        &quot;jmp 2b&quot;,
        &quot;2:&quot;,
        &quot;add {0}, 2&quot;,
        out(reg) a
    );
}
assert_eq!(a, 5);
<span class="boring">}
</span></code></pre></pre>
<p>This will decrement the <code>{0}</code> register value from 10 to 3, then add 2 and store it in <code>a</code>.</p>
<p>This example shows a few things:</p>
<ul>
<li>First, that the same number can be used as a label multiple times in the same inline block.</li>
<li>Second, that when a numeric label is used as a reference (as an instruction operand, for example), the suffixes â€œbâ€ (â€œbackwardâ€) or â€fâ€ (â€œforwardâ€) should be added to the numeric label. It will then refer to the nearest label defined by this number in this direction.</li>
</ul>
<h2 id="options"><a class="header" href="#options">Options</a></h2>
<p>By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However, in many cases it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.</p>
<p>Let's take our previous example of an <code>add</code> instruction:</p>
<pre><pre class="playground"><code class="language-rust edition2021">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::arch::asm;

let mut a: u64 = 4;
let b: u64 = 4;
unsafe {
    asm!(
        &quot;add {0}, {1}&quot;,
        inlateout(reg) a, in(reg) b,
        options(pure, nomem, nostack),
    );
}
assert_eq!(a, 8);
<span class="boring">}
</span></code></pre></pre>
<p>Options can be provided as an optional final argument to the <code>asm!</code> macro. We specified three options here:</p>
<ul>
<li><code>pure</code> means that the asm code has no observable side effects and that its output depends only on its inputs. This allows the compiler optimizer to call the inline asm fewer times or even eliminate it entirely.</li>
<li><code>nomem</code> means that the asm code does not read or write to memory. By default the compiler will assume that inline assembly can read or write any memory address that is accessible to it (e.g. through a pointer passed as an operand, or a global).</li>
<li><code>nostack</code> means that the asm code does not push any data onto the stack. This allows the compiler to use optimizations such as the stack red zone on x86-64 to avoid stack pointer adjustments.</li>
</ul>
<p>These allow the compiler to better optimize code using <code>asm!</code>, for example by eliminating pure <code>asm!</code> blocks whose outputs are not needed.</p>
<p>See the <a href="unsafe/../../reference/inline-assembly.html">reference</a> for the full list of available options and their effects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="macro"><a class="header" href="#macro">macro</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="write-tests"><a class="header" href="#write-tests">Write Tests</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="benchmark"><a class="header" href="#benchmark">Benchmark</a></h1>
<p>https://doc.rust-lang.org/unstable-book/library-features/test.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="unit-and-integration"><a class="header" href="#unit-and-integration">Unit and Integration</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assertions"><a class="header" href="#assertions">Assertions</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="asyncawait"><a class="header" href="#asyncawait">Async/Await</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="async-and-await"><a class="header" href="#async-and-await">async and await!</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="future"><a class="header" href="#future">Future</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pin-and-unpin"><a class="header" href="#pin-and-unpin">Pin and Unpin</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stream"><a class="header" href="#stream">Stream</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stand-library-todo"><a class="header" href="#stand-library-todo">Stand Library todo</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="string-3"><a class="header" href="#string-3">String</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="ace.js" type="text/javascript" charset="utf-8"></script>
        <script src="editor.js" type="text/javascript" charset="utf-8"></script>
        <script src="mode-rust.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-dawn.js" type="text/javascript" charset="utf-8"></script>
        <script src="theme-tomorrow_night.js" type="text/javascript" charset="utf-8"></script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
